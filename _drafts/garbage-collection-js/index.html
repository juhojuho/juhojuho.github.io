<p>학부 시절 운영체제 수업에서 OS를 직접 구현하다보면 간혹 메모리가 부족하다는 버그가 뜨곤 했다. 보통 메모리 누수(memory leakage) 때문인데 메모리를 할당(e.g., malloc)하고 나중에 할당 해제(e.g., free)를 하지 않아 불필요한 메모리가 계속 쌓여 발생한다. C 같은 low-level 언어는 프로그래머가 직접 메모리를 관리할 수 있다. 하지만 JS나 Python 같은 대부분의 high-level 언어는 개발자가 임의로 메모리를 관리하지 못한다. 흠, 그럼 high-level 언어는 메모리 누수 발생을 어떻게 막는 걸까? 이 역할을 하는 게 가비지 컬렉터(Garbage colletor)이다. 가비지 컬렉터는 필요 없어진 메모리를 자체적으로 판단해 할당을 해제하여 메모리 누수의 발생을 막는다. V8 같은 JS 엔진에도 가비지 컬렉션이 구현되어 있다. Garbage collection을 한국어로 검색해보니 &quot;쓰레기 수집&quot;이라고 뜨는데 어감이 참.. 하여튼 JS에 가비지 컬렉션이 어떻게 구현되어 있는지 알아보자!</p>
<h2 id="%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0">메모리 누수 관리하기 <a class="direct-link" href="#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0">#</a></h2>
<p>메모리 누수는 프로그램이 더이상 사용하지 않는 메모리가 OS에 의해 free memory로 반환되지 않는 현상을 가르킨다. 각 프로그래밍 언어마다 메모리를 제어하는 저마다의 방식을 가지고 있다. 보통 프로그래밍 언어 입장에서 메모리가 실제 필요한지 아닌지 파악하기는 힘들다. 현재 메모리에 저장된 값을 사용되고 있지 않더라도 개발자가 추후 사용할 수도 있기 떄문에 쉽게 판단하기 힘들다. 반대로 개발자는 프로그램이 어떻게 돌아갈지 본인이 직접 청사진을 그리므로 사용하지 않을 메모리를 판단할 수 있다. 이에 따라 특정 프로그래밍 언어는 개발자에게 약간의 권한을 제공한다. 일례로 C 언어에서 메모리 할당은 malloc() 함수를 통해 이뤄지며, 할당 해제틑 free() 함수를 통해 이뤄진다. 하지만 이 방식의 문제는 개발자를 너무 맹신하는 데 있다. 개발자가 까먹고 메모리 반환을 하지 않으면 그 만큼의 메모리는 불필요하게 컴퓨터의 리소스를 잡아 먹게 되어 메모리 누수가 발생한다.</p>
<h2 id="%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC">자바스크립트에서 메모리 관리 <a class="direct-link" href="#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC">#</a></h2>
<p>자바스크립트는 garbase collection 기능을 사용한다. 이런 종류의 언어들은 어떤 메모리가 reahced될 수 없는지 주기적으로 체킨해주면서 개발자를 돕는다. 다른 말로 가비지 콜렉션 언어는 메모리 관리의 문제를 &quot;어떤 메모리가 아직 필요한지&quot;를 &quot;어떤 메모리가 앱의 다른 부분에 위해 아직도 reach되는지&quot;로 축소시킨다. 차이점은 사소해 보일 수 있지만 중요하다. 오직 개발자가 어떤 메모리가 미래에도 필요한지 안다. 닿지 않는 메모리가 알고리즘적으로 결정되고 OS로 반환된다.</p>
<h2 id="%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98">자바스크립트에서 메모리 누수 <a class="direct-link" href="#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98">#</a></h2>
<p>garbage collected language에서 메모리 누수가 일어나는 가장 큰 원인은 unwanted reference이다. 이게 뭔지 이해하기 위해 가바지 콜렉터가 어떻게 메모리가 reachable한지 안 하는지 판단하는지 알아보자.</p>
<h2 id="mark-and-sweep">mark-and-sweep <a class="direct-link" href="#mark-and-sweep">#</a></h2>
<p>많은 garbase collector는 mark-and-sweep라는 알고리즘을 쓴다. 이 알고리즘은 다음의 단계대로 진행된다.</p>
<ol>
<li>garbase collertor는 roots의 리스트를 만든다. 루트는 주로 global variable로 그 reference가 코드에 유지된다. 자바스크립트에서 'window' object가 루트로 작용하는 global variable의 예시다. window object는 항상 존재하므로 garbase collector는 window 객체와 그 children이 항상 존재한다고 간주한다.</li>
<li>모든 루트는 active로 간주되고(즉, 가비지 아님). 모든 children도 recursive하게 조사된다. root로 부터 참조 가능한 모든 가비지는 이제 garbase가 아니다.</li>
<li>active로 표시되지 않은 모든 메모리 조각은 이제 garbage로 간주된다. 콜렉터는 이제 그 메모리를 해방하고 OS에게 넘겨준다.</li>
</ol>
<p>최신 GC는 이 알고리즘으로 여러 방식으로 진화시켰지만 기본 원리는 같다. 루트로 부터 갈 수 있는 메모리는 남겨두고 나머지 메모리는 garbage다.</p>
<p>Unwanted references는 개발자가 더이상 사용하지 않을 메모리 조각이지만 어찌된 이유에서인지 active 하다고 표시된 것들을 가리킨다. 자바스크립트에서 unwanted reference는 더 이상 쓰지 않을 거기 때문에 충분히 해방되도 괜찮지만 아직도 코드 어딘가에 남아 있는 변수를 가리킨다. 어떤 사람은 이 모든 게 개발자 잘못이라 말하기도 한다.</p>
<p>자바스크립트에서 흔한 메모리 누수를 이해하기 위해</p>
<h2 id="%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98%EC%9D%98-%ED%9D%94%ED%95%9C-%EC%84%B8-%EA%B0%80%EC%A7%80-%EA%B2%BD%EC%9A%B0">자바스크립트 메모리 누수의 흔한 세 가지 경우 <a class="direct-link" href="#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98%EC%9D%98-%ED%9D%94%ED%95%9C-%EC%84%B8-%EA%B0%80%EC%A7%80-%EA%B2%BD%EC%9A%B0">#</a></h2>
<h2 id="%EA%B2%B0%EB%A1%A0">결론 <a class="direct-link" href="#%EA%B2%B0%EB%A1%A0">#</a></h2>
<p>메모리 누수는 자바스크립트 같은 garbage collected language에서 일어난다. 메모리 누수는 우리 앱에 피해를 입힌다. 따라서 memory profiling tools는 메모리 누수를 찾는 데 필수적이다. 탐색 과정은 개발하면서 반드시 거쳐야 하며 특히 중간 규모 이상의 앱에서는 필수적이다. 당신의 유저에게 최고의 경험을 선사해 주기 위해 시작하라.</p>
