{
  "version": "https://jsonfeed.org/version/1",
  "title": "햄스터 갬성 블로그",
  "home_page_url": "https://juhojuho.github.io/",
  "feed_url": "https://juhojuho.github.io/",
  "description": "햄스터의 개발 관련 Tech Blog",
  "author": {
    "name": "선주호",
    "url": "https://juhojuho.github.io/"
  },
  "items": [{
      "id": "https://juhojuho.github.io/posts/open-api-generator-custom-template/",
      "url": "https://juhojuho.github.io/posts/open-api-generator-custom-template/",
      "title": "OpenAPI Generator 템플릿 변경하기",
      "content_html": "<p>이전에 진행하던 프로젝트에서 타입스크립트를 적극적으로 활용하지 못했다. 그 이유는 촉박한 개발 시간에 수백 개의 타입을 일일이 입력하기 버거웠기(+귀찮음) 때문이다. 그러던 중 옆 팀에서 개발한 꿀 라이브러리를 알게 되었다. 스웨거에 정의된 타입을 자동으로 타입스크립트 파일로 전환시키는 딱 찾던 기능이었다. 스웨거에 명세(specification)만 잘 작성되어 있다면 커맨드 한 줄로 그 성가신 작업이 단숨에 해결되었다. 위 라이브러리는 vue 기반이었고, 다행히 당시 프로젝트를 모두 vue로 진행하던 터라 찰떡이었다.</p>\n<p>이후 새로운 프로젝트에서 react를 사용하게 되었고, 이에 맞춰 새로운 라이브러리 개발이 필요했다. 나는 <a href=\"https://openapi-generator.tech/\">OpenAPI Generator</a>를 사용하는 방법을 모색했지만 변환된 타입 포맷이 우리가 원하는 방식이 아니었다. 특히, enum을 처리하는 방식이 우리 팀 내에서 다루던 것과 상이했다. 다행히 템플릿을 변경할 수 있어 우리가 바라는 포맷 대로 타입을 뽑을 수 있었다.</p>\n<p>결국 기존 라이브러리를 react에 맞춰 수정하는 방식으로 결정해 위 해결책이 쓰일 일은 없었다. 그렇지만 OpenAPI Generator의 템플릿을 변경하는 방법이 (영문 기준으로도) 잘 정리된 글이 없었기 때문에 이번 기회에 글로 남기게 되었다.</p>\n<h2 id=\"%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9D%B8-%EC%BB%A4%EB%A7%A8%EB%93%9C\">기본적인 커맨드 <a class=\"direct-link\" href=\"#%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9D%B8-%EC%BB%A4%EB%A7%A8%EB%93%9C\">#</a></h2>\n<p>우선 OpenApi Generator 설치 방법은 <a href=\"https://openapi-generator.tech/docs/installation\">공식 홈페이지</a>에 자세히 나와 있으니 참고하면 된다.</p>\n<p>기본적인 사용 방법은 다음과 같다. 각 flag에 대한 자세한 설명 역시 공식 홈페이지에 나와 있다. 이번 포스팅에서는 generator로 <code>typescript-axios</code>를 사용하도록 하겠다.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">openapi-generator generate <span class=\"token punctuation\">\\</span><br>  -i <span class=\"token variable\">${SPEC_FILE_PATH}</span> <span class=\"token punctuation\">\\</span><br>  -g <span class=\"token variable\">${GENERATOR_TYPE}</span> <span class=\"token punctuation\">\\</span><br>  -o <span class=\"token variable\">${OUTPUT_DIRECTORY}</span> <span class=\"token punctuation\">\\</span><br>  -t <span class=\"token variable\">${CUSTOM_TEMPLATE}</span> <span class=\"token punctuation\">\\</span><br><br>openapi-generator generate -i SWAGGER_URL -g typescript-axios -o ./output --skip-validate-spec</code></pre>\n<p>위 커맨드를 실행하면 output 폴더에 타입스크립트 타입과 axios api 호출 코드가 자동 생성된다. 기본으로 제공하는 템플릿을 사용하면 타입 출력물 예시는 아래와 같다.</p>\n<pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Student</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token comment\">/**<br>     * <br>     * @type {number}<br>     * @memberof Student<br>     */</span><br>    <span class=\"token string\">'age'</span><span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span><br>    <span class=\"token comment\">/**<br>     * <br>     * @type {string}<br>     * @memberof Student<br>     */</span><br>    <span class=\"token string\">'residence'</span><span class=\"token operator\">?</span><span class=\"token operator\">:</span> ResidenceEnum<span class=\"token punctuation\">;</span><br><span class=\"token punctuation\">}</span><br><span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> ResidenceEnum <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><br>    Seoul<span class=\"token operator\">:</span> <span class=\"token string\">'SEOUL'</span><span class=\"token punctuation\">,</span><br>    Incheon<span class=\"token operator\">:</span> <span class=\"token string\">'INCHEON'</span><span class=\"token punctuation\">,</span><br>    Busan<span class=\"token operator\">:</span> <span class=\"token string\">'BUSAN'</span><span class=\"token punctuation\">,</span><br><span class=\"token punctuation\">}</span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span></code></pre>\n<p>위 출력물에는 필요없는 정보가 포함되고 우리가 원하는 enum 처리 방식이 아니므로 이번 포스팅에서 아래와 같이 나타나도록 바꾸는 과정을 다룰 것이다.</p>\n<pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Student</span> <span class=\"token punctuation\">{</span><br>    age<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span><br>    residence<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token string\">'SEOUL'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'INCHEON'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'BUSAN'</span><br><span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"%ED%85%9C%ED%94%8C%EB%A6%BF-%EC%83%9D%EC%84%B1%EA%B3%BC-mustache\">템플릿 생성과 mustache <a class=\"direct-link\" href=\"#%ED%85%9C%ED%94%8C%EB%A6%BF-%EC%83%9D%EC%84%B1%EA%B3%BC-mustache\">#</a></h2>\n<p>커맨드 flag 중 -t를 통해 기본적으로 제공하는 템플릿이 아닌 우리가 자체적으로 설정한 템플릿을 사용할 수 있다. 처음부터 템플릿을 작성하려면 비효율적이므로 기본 템플릿에 우리 입맛대로 수정하는 방향이 더 낫다. 다음 커맨드로 기본 템플릿을 생성하자.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">openapi-generator author template -g typescript-axios -o custom_template</code></pre>\n<p>custom_template 폴더에 <code>.mustache</code> 확장자로 된 여러 파일을 생성된 것을 확인할 수 있다. <code>mustache</code>는 간단한 템플릿 엔진으로 쉽게 생각해서 (정확한 비유는 아니지만) model을 view로 바꾸는 과정이다. 인풋으로 들어온 변수를 미리 정해놓은 틀에 맞춰 다양한 언어 파일로 변환시킨다. <a href=\"https://mustache.github.io/mustache.5.html\">매뉴얼</a>을 확인하면 더 자세히 알 수 있지만 아래 필수적인 문법을 설명한다.</p>\n<ol>\n<li>{{key}} : key에 대응하는 값을 출력한다.</li>\n</ol>\n<pre class=\"language-text\"><code class=\"language-text\">// template<br>Hi, I'm {{name}}!<br><br>// input<br>{ name: 'Juho' }<br><br>// output<br>Hi, I'm Juho!</code></pre>\n<ol start=\"2\">\n<li>{{#key}} {{/key}} : if문으로 key가 true면 사이에 적힌 구문을 실행한다.</li>\n</ol>\n<pre class=\"language-text\"><code class=\"language-text\">// template<br>{{#isHuman}}<br>Juho<br>{{/isHuman}}<br><br>// input<br>{ isHuman: true }<br><br>// output<br>Juho</code></pre>\n<p>2-1. 만약 key에 대응하는 값이 리스트면 그 요소들을 열거한다.</p>\n<pre class=\"language-text\"><code class=\"language-text\">// template<br>{{#students}}<br>{{age}}<br>{{/students}}<br><br>// input<br>{ students: [ { age: 13 }, { age: 16 }, { age: 19 } ] }<br><br>// output<br>13<br>16<br>19</code></pre>\n<ol start=\"3\">\n<li>{{^key}} {{/key}} : 위 2번과 반대로 key가 false면 사이에 적힌 구문을 실행한다. key에 대응하는 값이 리스트면 그 요소들을 열거한다.</li>\n</ol>\n<pre class=\"language-text\"><code class=\"language-text\">// template<br>{{^isHuman}}<br>Hamster<br>{{/isHuman}}<br><br>// input<br>{ isHuman: false }<br><br>// output<br>Hamster</code></pre>\n<h2 id=\"%EC%BB%A4%EC%8A%A4%ED%85%80-%ED%85%9C%ED%94%8C%EB%A6%BF%EC%9C%BC%EB%A1%9C-%EB%B3%80%EA%B2%BD%ED%95%98%EA%B8%B0\">커스텀 템플릿으로 변경하기 <a class=\"direct-link\" href=\"#%EC%BB%A4%EC%8A%A4%ED%85%80-%ED%85%9C%ED%94%8C%EB%A6%BF%EC%9C%BC%EB%A1%9C-%EB%B3%80%EA%B2%BD%ED%95%98%EA%B8%B0\">#</a></h2>\n<p>custom_template 폴더의 <code>modelGeneric.mustache</code> 파일에 타입을 정의하는 템플릿이 있다. 우선 필요 없는 부분을 모두 삭제하자. enum을 정의하는 부분과 프로퍼티를 설명하는 부분(@type, @member 등)을 삭제한 후, 아래 코드의 수정이 필요하다.</p>\n<pre class=\"language-text\"><code class=\"language-text\">'{{baseName}}'{{^required}}?{{/required}}: {{#isEnum}}{{{datatypeWithEnum}}}{{/isEnum}}{{^isEnum}}{{{dataType}}}{{#isNullable}} | null{{/isNullable}}{{/isEnum}};<br>}</code></pre>\n<p><code>{{{datatypeWithEnum}}}</code> 부분을 수정해야 <code>'SEOUL' | 'INCHEON' | 'BUSAN'</code>와 같은 방식으로 enum을 표현할 수 있다. 우선, 위 enum에 대응하는 key가 무엇인지 알아야 한다. 이를 아는 방법은 아래와 같은 커맨드를 추가해 템플릿 엔진의 인풋으로 들어가는 값이 무엇인지 확인해야 한다. <code>generate</code> 커맨드의 마지막에 <code>--global-property debugModels=true</code>을 추가하면 각종 로그와 템플릿 엔진의 값이 모두 출력된다. 로그를 보면 아래와 같이 포맷으로 enum 멤버가 전달되는 것을 확인할 수 있다.</p>\n<pre class=\"language-json\"><code class=\"language-json\">...<br><span class=\"token property\">\"allowableValues\"</span> <span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token property\">\"enumVars\"</span> <span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>...<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><br>    <span class=\"token property\">\"values\"</span> <span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span> <span class=\"token string\">\"SEOUL\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"INCHEON\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"BUSAN\"</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span><br><span class=\"token punctuation\">}</span><br>...</code></pre>\n<p>위 <code>values</code>에 담긴 값이 <code>'SEOUL' | 'INCHEON' | 'BUSAN'</code>와 같이 표현될 수 있도록 다음 과정을 거쳐 템플릿을 변경해야 한다.</p>\n<ol>\n<li>우선, 내부값에 접근하기 위해 <code>allowableValues</code>와 <code>values</code>가 유효한 값인지 확인해야 한다.</li>\n</ol>\n<pre class=\"language-text\"><code class=\"language-text\">{{#allowableValues}}{{#values}}{{/values}}{{/allowableValues}}</code></pre>\n<ol start=\"2\">\n<li>이제 값을 작은 따음표와 함께 출력하고, 각 멤버를 구분하기 위해 <code>|</code>를 공백과 함께 추가한다.</li>\n</ol>\n<pre class=\"language-text\"><code class=\"language-text\">{{#allowableValues}}{{#values}}'{{.}}' | {{/values}}{{/allowableValues}}</code></pre>\n<ol start=\"3\">\n<li>이 때, 마지막 멤버 뒤에는 <code>|</code>가 출력되면 안 되므로 이를 방지하는 조건문을 추가한다.</li>\n</ol>\n<pre class=\"language-text\"><code class=\"language-text\">{{#allowableValues}}{{#values}}'{{.}}'{{^-last}} | {{/-last}}{{/values}}{{/allowableValues}}</code></pre>\n<p>여기까지 완성된 템플릿으로 다시 generator를 돌리면 우리가 원하는 방식대로 타입스크립트 타입 파일이 출력될 것이다. 이 글은 간단한 튜토리얼로 따라오는데 꼭 필요한 정보만 설명했다. 이외에도 수많은 옵션이 존재하므로 아래 레퍼런스를 참고해 원하는 커스텀 템플릿을 만들 수 있다.</p>\n<p><strong>Reference</strong><br>\n<a href=\"https://openapi-generator.tech/\">OpenAPI Generator 공식 홈페이지</a><br>\n<a href=\"https://github.com/OpenAPITools/openapi-generator/blob/master/docs/templating.md\">OpenAPI Generator 템플릿 문서</a><br>\n<a href=\"https://mustache.github.io/mustache.5.html\">mustache 매뉴얼</a></p>\n",
      "date_published": "2022-12-13T15:00:00+09:00"
    },{
      "id": "https://juhojuho.github.io/posts/frontend-codetest-1/",
      "url": "https://juhojuho.github.io/posts/frontend-codetest-1/",
      "title": "[FE 면접] 자바스크립트에서 어떻게 객체의 속성 변경을 막을 수 있을까?",
      "content_html": "<h3 id=\"%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8\">면접 질문 <a class=\"direct-link\" href=\"#%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8\">#</a></h3>\n<p>객체(object)의 속성(property)의 변경을 막는 방법을 설명하라. 즉, 다음과 같이 이미 선언된 객체의 <code>name</code> 속성 변경을 막는 코드를 작성하라.</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> guest <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><br>    name<span class=\"token operator\">:</span> <span class=\"token string\">'John'</span><span class=\"token punctuation\">,</span><br>    age<span class=\"token operator\">:</span> <span class=\"token number\">25</span><br><span class=\"token punctuation\">}</span><br><br>guest<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'Peter'</span> <span class=\"token comment\">// ?</span></code></pre>\n<h3 id=\"%EB%82%98%EB%A7%8C%EC%9D%98-%EB%8C%80%EB%8B%B5\">나만의 대답 <a class=\"direct-link\" href=\"#%EB%82%98%EB%A7%8C%EC%9D%98-%EB%8C%80%EB%8B%B5\">#</a></h3>\n<p>설명자(Descriptor)를 활용하여 객체의 속성값 변경을 막을 수 있다. 설명자는 말 그대로 객체의 한 속성에 대한 정보를 <strong>설명</strong>하는 값으로 다음과 같은 몇 가지 정보를 내포한다.</p>\n<ol>\n<li>value: 해당 속성의 값(위 코드에서 'John')</li>\n<li>writable: 해당 속성의 변경 가능 여부</li>\n<li>configurable: 해당 속성의 <code>Object.defineProperty()</code>를 통한 설정 가능 여부</li>\n<li>enumerable: 해당 속성이 열거 중에 나타나는 여부 (예를 들어, false로 설정하면 <code>Object.values()</code> 실행 중에 해당 속상이 나타나지 않는다)</li>\n</ol>\n<p>설명자는 <code>Object.getOwnPropertyDescriptor(object, property)</code>를 통해 찾을 수 있다.</p>\n<pre class=\"language-js\"><code class=\"language-js\">Object<span class=\"token punctuation\">.</span><span class=\"token function\">getOwnPropertyDescriptor</span><span class=\"token punctuation\">(</span>guest<span class=\"token punctuation\">,</span> <span class=\"token string\">'name'</span><span class=\"token punctuation\">)</span><br><span class=\"token comment\">// {value: 'John', writable: true, enumerable: true, configurable: true}</span></code></pre>\n<p>이 중에서 <code>writable</code>이 객체의 속성 변경과 관련되어 있다. 값을 false로 설정하면 해당 객체의 속성 변경을 막을 수 있다.</p>\n<p><code>Object.defineProperty(object, property, descriptor)</code>를 통해 설명자를 변경할 수 있다. 참고로 <code>configurable</code>이 false로 설정되어 있으면 위 함수를 통해 설정자 변경이 불가능하다. 다음과 같이 <code>name</code> 속성의 변경을 막을 수 있다.</p>\n<pre class=\"language-js\"><code class=\"language-js\">Object<span class=\"token punctuation\">.</span><span class=\"token function\">defineProperty</span><span class=\"token punctuation\">(</span>guest<span class=\"token punctuation\">,</span> <span class=\"token string\">'name'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> writable<span class=\"token operator\">:</span> <span class=\"token boolean\">false</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><br><br>guest<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'Peter'</span><br>guest<span class=\"token punctuation\">.</span>name <span class=\"token comment\">// 'John'</span></code></pre>\n<p>위에서 보듯이 <code>name</code> 속성 변경 시도에 에러가 발생하진 않지만 실제 값에 변경은 일어나지 않았다.</p>\n<h3 id=\"%2B%EC%95%8C%ED%8C%8C\">+알파 <a class=\"direct-link\" href=\"#%2B%EC%95%8C%ED%8C%8C\">#</a></h3>\n<p>설명자를 통해 속성의 열거를 막을 수도 있다. <code>enumerable</code>을 false로 설정하면 된다.<br>\n만약 객체에 속한 모든 속성의 변경을 막고 싶으면 <code>Object.freeze(object)</code>를 사용하면 된다. 위 함수는 모든 속성의 <code>writable</code>과 <code>configurable</code>를 flase로 설정한다.</p>\n<pre class=\"language-js\"><code class=\"language-js\">Object<span class=\"token punctuation\">.</span><span class=\"token function\">freeze</span><span class=\"token punctuation\">(</span>guest<span class=\"token punctuation\">)</span><br><br>Object<span class=\"token punctuation\">.</span><span class=\"token function\">getOwnPropertyDescriptor</span><span class=\"token punctuation\">(</span>guest<span class=\"token punctuation\">,</span> <span class=\"token string\">'name'</span><span class=\"token punctuation\">)</span><br><span class=\"token comment\">// {value: 'John', writable: false, enumerable: true, configurable: false}</span><br>Object<span class=\"token punctuation\">.</span><span class=\"token function\">getOwnPropertyDescriptor</span><span class=\"token punctuation\">(</span>guest<span class=\"token punctuation\">,</span> <span class=\"token string\">'age'</span><span class=\"token punctuation\">)</span><br><span class=\"token comment\">// {value: 25, writable: false, enumerable: true, configurable: false}</span></code></pre>\n<p><strong>Reference</strong><br>\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor\">Object.getOwnPropertyDescriptor() - JavaScript | MDN</a><br>\n<a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\">Object.freeze() - JavaScript - MDN Web Docs</a></p>\n",
      "date_published": "2022-11-17T15:00:00+09:00"
    },{
      "id": "https://juhojuho.github.io/posts/garbage-collection-js/",
      "url": "https://juhojuho.github.io/posts/garbage-collection-js/",
      "title": "[JS] 가비지 컬렉션 (Garbage Collection)",
      "content_html": "<p>학부 시절 운영체제 수업에서 OS를 직접 구현하다보면 간혹 메모리가 부족하다는 버그가 뜨곤 했다. 보통 메모리 누수(memory leakage) 때문인데 메모리를 할당(e.g., malloc)하고 나중에 할당 해제(e.g., free)를 하지 않아 불필요한 메모리가 계속 쌓여 발생한다. C 같은 low-level 언어는 프로그래머가 직접 메모리를 관리할 수 있다. 하지만 JS나 Python 같은 대부분의 high-level 언어는 개발자가 임의로 메모리를 관리하지 못한다. 흠, 그럼 high-level 언어는 메모리 누수 발생을 어떻게 막는 걸까? 이 역할을 하는 게 가비지 컬렉터(Garbage colletor)이다. 가비지 컬렉터는 필요 없어진 메모리를 자체적으로 판단해 할당을 해제하여 메모리 누수의 발생을 막는다. V8 같은 JS 엔진에도 가비지 컬렉션이 구현되어 있다.</p>\n<h2 id=\"%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0\">메모리 누수 관리하기 <a class=\"direct-link\" href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0\">#</a></h2>\n<p>메모리 누수는 프로그램이 더이상 사용하지 않는 메모리가 OS에 의해 사용 가능한 메모리(free memory)로 반환되지 않는 현상을 가르킨다. 각 프로그래밍 언어마다 메모리를 제어하는 저마다의 방식을 가지고 있다. 보통 프로그래밍 언어 입장에서 메모리가 실제 필요한지 아닌지 파악하기는 힘들다. 현재 메모리에 저장된 값을 사용되고 있지 않더라도 개발자가 추후 사용할 수도 있기 떄문에 쉽게 판단하기 힘들다. 반대로 개발자는 프로그램이 어떻게 돌아갈지 본인이 직접 청사진을 그리므로 사용하지 않을 메모리를 판단할 수 있다. 이에 따라 특정 프로그래밍 언어는 개발자에게 약간의 권한을 제공한다. C 언어에서 메모리 할당은 malloc 함수를 통해 이뤄지며, 할당 해제틑 free 함수를 통해 이뤄진다. 하지만 이 방식의 약점은 개발자를 너무 맹신하는 데 있다. 개발자가 까먹고 메모리 반환을 하지 않으면 그 만큼의 메모리는 불필요하게 컴퓨터의 리소스를 잡아 먹게 되어 메모리 누수가 발생한다.</p>\n<h2 id=\"%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98\">자바스크립트에서 가비지 컬렉션 <a class=\"direct-link\" href=\"#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98\">#</a></h2>\n<p>자바스크립트는 가비지 컬렉션 기능을 사용한다. 이런 종류의 언어들은 어떤 메모리가 사용되고 있는지 주기적으로 체크해주면서 개발자를 돕는다. 가비지 컬렉션 언어에서 메모리 관리의 문제는 &quot;어떤 메모리가 아직 필요한지&quot;를 &quot;어떤 메모리가 앱의 다른 부분에 의해 아직도 접근되는지(reachable)&quot;로 치환된다. 차이점은 사소해 보일 수 있지만 중요하다. 접근되고 있지 않는(unreachable) 메모리는 알고리즘적으로 결정되고 OS로 반환된다. 실제 가비지 컬렉터에서 사용하고 있는 알고리즘 중 대표적인 예는 mark-and-sweep이다.</p>\n<h2 id=\"mark-and-sweep-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">mark-and-sweep 알고리즘 <a class=\"direct-link\" href=\"#mark-and-sweep-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">#</a></h2>\n<p>mark-and-sweep 알고리즘은 다음의 단계대로 진행된다.</p>\n<ol>\n<li>가비지 컬렉터는 root(루트)의 리스트를 만든다. 루트는 주로 전역 변수(global variable)로 그 reference가 코드에 유지된다. 자바스크립트에서 'window' 객체가 루트로 작용하는 전역 변수의 한 예시다. window 객체는 항상 어떤 상황에서도 사용되므로, 가비지 컬렉터는 window 객체를 항상 접근 가능하다고(reachable) 간주한다.</li>\n<li>모든 루트는 접근 가능하다고 간주되고, 해당 루트의 속성을 타고 내려가며 참조 가능한 메모리가 있는지 재귀적으로(recursive)으로 조사된다. 루트로부터 참조 가능한 모든 메모리는 접근 가능하다고 판단한다.</li>\n<li>접근되지 않는다고 판단된 메모리 조각은 가비지로 간주된다. 가비지 컬렉터는 이제 가비지 메모리 조각을 해제하여 사용 가능한 메모리로 반환한다.</li>\n</ol>\n<p>최신 가비지 컬렉터는 이 알고리즘을 기반으로 여러 방식으로 진화되었지만 기본 원리는 같다. 루트로부터 참조 가능한 메모리는 남겨두고 나머지 메모리는 가비지로 판단하여 반환한다. 하지만 가비지 컬렉터가 완벽한 알고리즘을 갖췄다 해도 메모리 누수가 발생할 수 있다.<br>\n자바스크립트에서 메모리 누수가 일어나는 가장 큰 원인은 원치 않은 참조(unwanted reference)가 유지되는 경우이다.</p>\n<h2 id=\"%EC%9B%90%EC%B9%98-%EC%95%8A%EC%9D%80-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98%EA%B0%80-%EB%B0%9C%EC%83%9D%ED%95%98%EB%8A%94-%EA%B2%BD%EC%9A%B0\">원치 않은 메모리 누수가 발생하는 경우 <a class=\"direct-link\" href=\"#%EC%9B%90%EC%B9%98-%EC%95%8A%EC%9D%80-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98%EA%B0%80-%EB%B0%9C%EC%83%9D%ED%95%98%EB%8A%94-%EA%B2%BD%EC%9A%B0\">#</a></h2>\n<p>Unwanted reference는 개발자가 더이상 사용하지 않지만 어찌된 이유에서인지 접근 가능하다고 여겨지는 메모리 조각이다. 즉, 더 이상 사용되지 않기 때문에 충분히 해방되도 괜찮지만, 아직도 코드 어딘가에 남아 있는 변수를 가리킨다. 가장 빈번하게 발생하는 경우는 전역 객체(즉, window)에 변수를 할당할 때이다.</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    text <span class=\"token operator\">=</span> <span class=\"token string\">\"I'm accidently referenced -_-\"</span><br>    <span class=\"token comment\">// 위 코드는 아래와 동일하다.</span><br>    <span class=\"token comment\">// window.text = \"I'm accidently referenced -_-\"</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>위 코드에서 text 변수는 선언 키워드(var, let 등)가 사용되지 않았기 때문에 window 객체에 선언된다. 위 mark-and-sweep 알고리즘에 따라 가비지 컬렉터는 window 객체에 포함된 text 변수가  항상 접근 가능하다고 판단한다. 원래라면 print 함수의 종료와 함께 해방되어야 하지만 가비지 컬렉션은 알고리즘 상으로 이를 인지하지 못하고 메모리 누수가 발생하게 된다. 만약 var 등을 통해 변수를 선언했다면, text는 지역 변수(local variable)가 되어 함수의 종료와 함께 접근 가능하지 않은 메모리로 판단되어 메모리에서 해방된다. 이같은 케이스는 전적으로 개발자의 실수에서 비롯된다. 이외에도 unwanted reference가 발생하는 여러 경우가 있는데, 더 자세한 사항은 아래 레퍼런스를 참조하길 바란다.</p>\n<p>메모리 누수는 자바스크립트 같이 가비지 컬렉터를 사용하는 언어에서도 발생할 수 있다. 메모리 누수가 반복되면 시스템에 심각한 에러를 초래할 수 있다. 따라서, 개발자들은 항상 예상치 못한 메모리 누수가 발생하지 않도록 의식해야 한다. 사용자 경험에도 영향을 미칠 수 있는 부분이라 프론트엔드 개발자도 항상 유의해야 할 사항인 것 같다.</p>\n<p><strong>Reference</strong><br>\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management\">Memory management - JavaScript | MDN</a><br>\n<a href=\"https://auth0.com/blog/four-types-of-leaks-in-your-javascript-code-and-how-to-get-rid-of-them/\">4 Types of Memory Leaks in JavaScript and How to Get Rid Of Them</a></p>\n",
      "date_published": "2022-11-16T15:00:00+09:00"
    },{
      "id": "https://juhojuho.github.io/posts/window10-usb-from-mac/",
      "url": "https://juhojuho.github.io/posts/window10-usb-from-mac/",
      "title": "맥OS에서 윈도우10 설치 USB 만들기",
      "content_html": "<p>우리나라에서 애플 제품으로만 사는 것은 다소 힘들다. 악명 높은 공인인증서의 존재와 공공 사이트에서도 윈도우 위주로 지원을 해주기 때문이다. 나는 맥북을 쓰고 있고 연구실 데스크탑도 iMac을 쓰고 있다. 마침 컴퓨존에서 특가로 나온 제품이 있길래 저렴한 가격에 윈도우용 데스크탑을 구매했다. 이제 윈도우10만 깔면 되는데 마침 우리학교에 각종 S/W를 제공하는 서비스가 있었다. 오호라 그럼 윈도우 설치용 usb만 만들면 금방 끝나겠구만! 했는데.. macOS에서 윈도우 설치 usb를 만드는 게 생각보다 까다로웠다..</p>\n<h2 id=\"1%EB%8B%A8%EA%B3%84%3A-window10-ios-%EB%8B%A4%EC%9A%B4%EB%A1%9C%EB%93%9C\">1단계: Window10 IOS 다운로드 <a class=\"direct-link\" href=\"#1%EB%8B%A8%EA%B3%84%3A-window10-ios-%EB%8B%A4%EC%9A%B4%EB%A1%9C%EB%93%9C\">#</a></h2>\n<p>우선 설치하고 싶은 윈도우10 버전의 ISO 파일을 구하자. 또한 8GB 이상의 USB를 준비하자.</p>\n<h2 id=\"2%EB%8B%A8%EA%B3%84%3A-udb-%ED%8F%AC%EB%A7%B7-%EB%B0%A9%EC%8B%9D-%EB%B3%80%EA%B2%BD\">2단계: UDB 포맷 방식 변경 <a class=\"direct-link\" href=\"#2%EB%8B%A8%EA%B3%84%3A-udb-%ED%8F%AC%EB%A7%B7-%EB%B0%A9%EC%8B%9D-%EB%B3%80%EA%B2%BD\">#</a></h2>\n<p>USB를 맥에 연결하고 &quot;Disk Utility&quot; 프로그램을 연다. 상단의 &quot;Erase&quot; 버튼을 누루고 'Fromat' 칸에 &quot;MS-ODS (FAT)&quot;를 선택한다. 'Name'은 아무거나 입력해도 된다.</p>\n<h2 id=\"3%EB%8B%A8%EA%B3%84%3A-%EB%B3%B5%EC%82%AC-%EB%B6%99%EC%97%AC%EB%84%A3%EA%B8%B0\">3단계: 복사 붙여넣기 <a class=\"direct-link\" href=\"#3%EB%8B%A8%EA%B3%84%3A-%EB%B3%B5%EC%82%AC-%EB%B6%99%EC%97%AC%EB%84%A3%EA%B8%B0\">#</a></h2>\n<p>다운로드받은 ISO 파일을 더블 클릭하여 마운트하자. ISO 파일 안의 세부 파일을 모두 복사하여 USB에 붙여넣자. 아마 드래그 해서 붙여넣는 방법으로 하면 용량이 너무 커서 오류가 뜰 것이자. 커맨드를 사용하면 해결된다. 터미널을 열고 아래와 같이 입력하자.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">cd</span> /Volumes/<span class=\"token punctuation\">{</span>PATHtoISOFiles<span class=\"token punctuation\">}</span>/ <span class=\"token comment\"># ISO 파일이 마운트된 폴더로 이동</span><br><span class=\"token function\">cp</span> -R ./* /Volumes/<span class=\"token punctuation\">{</span>USBNames<span class=\"token punctuation\">}</span>/ <span class=\"token comment\"># ISO 안의 모든 파일을 USB로 복사</span></code></pre>\n<h2 id=\"4%EB%8B%A8%EA%B3%84%3A-%EC%9A%A9%EB%9F%89-%EC%AA%BC%EA%B0%9C%EA%B8%B0\">4단계: 용량 쪼개기 <a class=\"direct-link\" href=\"#4%EB%8B%A8%EA%B3%84%3A-%EC%9A%A9%EB%9F%89-%EC%AA%BC%EA%B0%9C%EA%B8%B0\">#</a></h2>\n<p>끝~ 인줄 알았으나 아마 복사하는 도중 또다시 문제가 생겼을 것이다.</p>\n<blockquote>\n<p>“install.wim: File too large”</p>\n</blockquote>\n<p>우리가 2단계에서 선택한 <code>FAT(FAT32)</code> 포맷 지원하는 한 파일의 용량은 최대 4GB이다. 그런데 우리가 복사하는 파일 중 <code>ìnstall.wim</code>의 용량은 4GB가 넘는다. 여기서 문제가 발생한다. (설치하고자 하는 윈도우 버전에 따라 위 오류가 발생하지 않을 수도 있다. 예전 버전에는 해당 파일의 용량이 4GB 이하였다.)<br>\n해결책은 <code>install.wim</code> 파일을 4GB 이하의 파일 2개로 쪼개는 것이다. 먼저 <code>wimlib</code>이라는 library를 설치하자.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># Homewbrew가 설치되지 않았을 시</span><br>/bin/bash -c <span class=\"token string\">\"<span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">curl</span> -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh<span class=\"token variable\">)</span></span>\"</span><br><span class=\"token comment\"># wimlib을 Homebrew를 통해 설치</span><br>brew <span class=\"token function\">install</span> wimlib</code></pre>\n<p>그 후, 아래의 커맨드로 파일을 분할하자.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># install.wim 파일을 3800MB(&lt; 4GB)의 파일로 분할</span><br>wimlib-imagex <span class=\"token function\">split</span> /Volumes/<span class=\"token punctuation\">{</span>PATHtoISOFiles<span class=\"token punctuation\">}</span>/sources/install.wim /Volumes/<span class=\"token punctuation\">{</span>USBNames<span class=\"token punctuation\">}</span>/sources/install.swm <span class=\"token number\">3800</span></code></pre>\n<p>여기까지 마쳤으면 큰 문제없이 설치 USB가 완성되었을 것이다. 이제 데스크탑에 usb를 연결하고 바이오스에서 부팅 순서를 바꿔 재부팅하여 윈도우를 설치하면 된다. 이 부분에 대해서 구글 검색을 하면 자세한 설명이 많이 나온다.</p>\n",
      "date_published": "2021-08-31T15:00:00+09:00"
    },{
      "id": "https://juhojuho.github.io/posts/js-set/",
      "url": "https://juhojuho.github.io/posts/js-set/",
      "title": "[JS] Set",
      "content_html": "<p><code>Set</code>은 <code>Map</code>과 마찬가지로 ES6에 들어 새로 추가된 built-in object 중 하나이다. &quot;Set&quot;이란 이름답게 우리가 고등학교 1학년 수학시간 첫 단원에서 배웠던 집합과 기능이 유사하다. 집합의 가장 큰 특징이 무엇인가. <strong>집합의 원소들은 서로 다르며, 같은 원소가 여러 개 있을 수 없다.</strong> JS의 <code>Set</code>의 특징 역시 여기서 크게 벗어나지 않는다.</p>\n<h2 id=\"10-%EA%B0%80-1%EB%8B%A8%EC%9B%90-%EC%A7%91%ED%95%A9\">10-가 1단원 집합 <a class=\"direct-link\" href=\"#10-%EA%B0%80-1%EB%8B%A8%EC%9B%90-%EC%A7%91%ED%95%A9\">#</a></h2>\n<p><code>Set</code>은 수학의 집합과 같이 중복된 값을 포함할 수 없다. 대신 <code>Set</code> 속에 존재하는 값이 아니라면 어떠한 값도 그 안에 새로 포함될 수 있다. <code>String</code>, <code>Boolean</code> 같은 primitive value는 물론이고 <code>Array</code> 등의 ojbect 기반의 값도 가능하다. <code>Set</code>에 새 값을 더할 때는 <code>.add()</code>를 사용하자.</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> newSet <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Set</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>newSet<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">123</span><span class=\"token punctuation\">)</span><br>newSet<span class=\"token punctuation\">.</span>size <span class=\"token comment\">// 1</span><br>newSet<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">123</span><span class=\"token punctuation\">)</span><br>newSet<span class=\"token punctuation\">.</span>size <span class=\"token comment\">// 1</span><br>newSet<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>id<span class=\"token operator\">:</span> <span class=\"token number\">4</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><br>newSet<span class=\"token punctuation\">.</span>size <span class=\"token comment\">// 2</span><br>newSet<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>id<span class=\"token operator\">:</span> <span class=\"token number\">4</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><br>newSet<span class=\"token punctuation\">.</span>size <span class=\"token comment\">// 3</span></code></pre>\n<p>앗! 혹시 위 결과가 이상하다고 느꼈는가. 아까 분명히 <code>Set</code> 안에 중복된 값이 못 들어간다고 했는데 ojbect <code>{id: 4}</code>가 두번 들어갔다. 이는 <code>Set</code> 안에 해당 object를 가리키는 주소값(reference)가 저장되기 때문이다. 비록 내용은 같을 지라도 각각 다른 주소값을 가지기 때문에 <code>Set</code>에 문제 없이 추가되었다. <code>{a: 1} == {a: 1}</code>의 결과가 <code>false</code>인 것과 같은 이치다.</p>\n<h2 id=\"set-%EC%A0%9C%EB%8C%80%EB%A1%9C-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0\">Set 제대로 활용하기 <a class=\"direct-link\" href=\"#set-%EC%A0%9C%EB%8C%80%EB%A1%9C-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0\">#</a></h2>\n<p><code>Set</code>을 다루기 위한 method는 다음과 같다.</p>\n<ul>\n<li><code>new Set</code>: 빈 <code>Set</code>을 생성한다.</li>\n<li><code>new Set(iterable)</code>: 빈 <code>Set</code>을 생성하고 파라미터로 받은 iterable ojbect 속 값을 중복되지 않게 채워넣는다. 만약 array에 있는 중복된 값을 제거하고 싶을 때, 이 방법을 사용하면 단 한 줄로 원하는 결과를 얻을 수 있다.</li>\n<li><code>set.size</code>: <code>Set</code>에 속한 값의 수를 반환한다.</li>\n<li><code>set.has(value)</code>: 만약 파라미터로 받은 value가 <code>Set</code>에 속하면 <code>true</code>를 반환한다.</li>\n<li><code>set.add(value)</code>: 파라미터로 받은 value을 <code>Set</code>에 추가한다. 만약 이미 존재하면 추가하지 않는다.</li>\n<li><code>set.delete(value)</code>: 파라미터로 받은 value가 <code>Set</code>에 포함되어 있으면 제거한다.</li>\n<li><code>set.keys(), set.values(), set.entries()</code>: <code>Map</code>의 그것과 동일하다. <a href=\"https://juhojuho.github.io/posts/js-map/\">Map 포스트</a> 참고</li>\n</ul>\n<h2 id=\"%ED%95%9C-%EA%B0%80%EC%A7%80%EB%A7%8C-%EB%8D%94-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90!\">한 가지만 더 알아보자! <a class=\"direct-link\" href=\"#%ED%95%9C-%EA%B0%80%EC%A7%80%EB%A7%8C-%EB%8D%94-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90!\">#</a></h2>\n<p>한 가지 의문점이 든다. <code>Set</code>에서 말하는 &quot;동일한 값&quot;의 판단 기준은 무엇일까? Boolean type <code>true</code>와 String type <code>&quot;true&quot;</code>는 같을까? 정답은.. 아니요! 기본적으로 <code>===</code> operation과 비슷하다고 생각하면 된다. <code>===</code>는 우선 값을 비교하고, type도 같은지 비교한다. 따라서 위 경우는 값은 같으나 type이 다르기 때문에 한 <code>Set</code> 안에 들어갈 수 있다. 사소한 팁으로 primitive type 중 하나인 NaN을 서로 비교하면 <code>===</code> 결과 서로 다른 값이라 판단되지만 <code>Set</code> 안에서는 같은 값이라 판단되어 단 하나만 추가된다. <em>(진짜 사소하다..)</em></p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> numSet <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Set</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"1\"</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// {\"1\"}</span><br>numSet<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// {\"1\", 1}</span><br>numSet<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// {\"1\", 1, true}</span><br>numSet<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"true\"</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// {\"1\", 1', true, \"true\"}</span><br>numSet<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">NaN</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// {\"1\", 1', true, \"true\", NaN}</span><br>numSet<span class=\"token punctuation\">.</span>size <span class=\"token comment\">// 5</span><br>numSet<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">NaN</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// {\"1\", 1', true, \"true\", NaN}</span><br>numSet<span class=\"token punctuation\">.</span>size <span class=\"token comment\">// 5</span></code></pre>\n<p><strong>Reference</strong><br>\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\">Set - JavaScript | MDN</a><br>\n<a href=\"https://hacks.mozilla.org/2015/06/es6-in-depth-collections/\">ES6 In Depth: Collections</a></p>\n",
      "date_published": "2020-08-23T15:00:00+09:00"
    },{
      "id": "https://juhojuho.github.io/posts/js-symbol/",
      "url": "https://juhojuho.github.io/posts/js-symbol/",
      "title": "[JS] Symbol",
      "content_html": "<p>이번 포스트의 주제는 Symbol이다. ES6를 배울 때 보통은 소외당하는 개념이지만 자바스크립트가 최초로 표준화된 1997년 이래 처음으로 추가된 새로운 타입인 만큼 자세히 알아보자.</p>\n<h2 id=\"%EC%8B%AC%EB%B2%8C%EC%A6%88-%EB%A7%90%EA%B3%A0-symbol\">심벌즈 말고 Symbol <a class=\"direct-link\" href=\"#%EC%8B%AC%EB%B2%8C%EC%A6%88-%EB%A7%90%EA%B3%A0-symbol\">#</a></h2>\n<p>먼저 symbol을 사용한 코드를 보자.</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> sym1 <span class=\"token operator\">=</span> <span class=\"token function\">Symbol</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br> <br><span class=\"token keyword\">typeof</span> sym1 <span class=\"token comment\">// \"symbol\"</span><br> <br><span class=\"token keyword\">var</span> sym2 <span class=\"token operator\">=</span> <span class=\"token function\">Symbol</span><span class=\"token punctuation\">(</span><span class=\"token string\">'password'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><span class=\"token keyword\">var</span> sym3 <span class=\"token operator\">=</span> <span class=\"token function\">Symbol</span><span class=\"token punctuation\">(</span><span class=\"token string\">'password'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br> <br>sym2 <span class=\"token operator\">===</span> sym3<span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span><br> <br><span class=\"token keyword\">var</span> sym4 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Symbol</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// TypeError</span><br> <br><span class=\"token keyword\">var</span> symObj <span class=\"token operator\">=</span> <span class=\"token function\">Object</span><span class=\"token punctuation\">(</span>sym<span class=\"token punctuation\">)</span><br><span class=\"token keyword\">typeof</span> symObj <span class=\"token comment\">// \"object\"</span></code></pre>\n<p>오! 몇 가지 신기한 결과가 나왔다. 하나씩 살펴보자.</p>\n<p>우선 symbol은 literal하게 선언할 수 없다. string의 경우 <code>var str = &quot;Hello, world!&quot;</code>와 <code>var str = String(&quot;Hello, world!&quot;)</code> 두 가지 방법으로 변수를 선언할 수 있지만 symbol은 반드시 <code>Symbol()</code> 함수를 이용해야 한다.</p>\n<p>또한, 앞서 말했듯이 symbol은 ES6에서 새로 추가된 타입이다. 가끔 object에 속한다고 생각하는 사람들도 있는데 결코 아니다. 위 코드에서 <code>typeof</code>의 결과로 <code>&quot;symbol&quot;</code>이 나옴을 알 수 있다.</p>\n<p><code>Symbol()</code> 함수의 매개변수는 선택사항이다. <code>sym1</code>처럼 비워둬도 되고 <code>sym2</code>나 <code>sym3</code>처럼 값을 넣어줘도 된다. 여기서 질문! 그렇다면 symbol에서 매개변수의 역할은 무엇일까?</p>\n<p>매개변수는 그 symbol이 무엇인지 <strong>설명</strong>해준다. 여기서 많은 사람이 헷갈린다. 많은 사람이 매개변수가 그 symbol의 <strong>값</strong>을 의미한다고 생각한다. 결코 아니다. 다시 한번 강조하지만, 그 symbol에 대한 <strong>설명</strong>일 뿐이다. 다른 개발자가 <code>sym2</code>를 보고 &quot;아, 패스워드와 관련된 symbol이구나&quot; 정도만 알게 하면 되는 그 이상 이하의 역할도 아니다. 그래서 <code>sym2</code>와 <code>sym3</code>를 비교하면 <code>false</code>가 나온다. 단순히 symbol에 붙은 <strong>설명</strong>만 같을 뿐 완전히 서로 다른 symbol이기 때문이다. symbol은 선언된 순간 세상에서 유일한 존재가 된다. <code>sym2</code>와 <code>sym3</code>가 다르듯이 매개변수가 같은 symbol을 포함한 그 어떤 것과도 같지 않게 된다. 이에 대해서는 뒤에서 좀 더 다루겠다.</p>\n<p>마지막으로 symbol을 선언하는 데 <code>new</code>를 쓰면 <code>TypeError</code>가 뜬다. 즉, <code>new</code>를 이용해 object로 'boxing'이 불가능하다. 다른 primitive 타입의 경우 <code>var year = new Number(2017)</code>처럼 <code>new</code>를 사용하면 타입이 object로 변환(coercion)된다. 하지만 symbol의 경우에는 object로 변환이 허용되지 않는다. 하지만 하늘이 무너져도 솟아날 구멍은 있는 법! <code>Object()</code> 함수를 이용하면 강제로 object로 변환시킬 수 있다. 위 코드의 가장 아랫줄을 보면 <code>symObj</code>의 타입이 &quot;object&quot;로 변했다.</p>\n<h2 id=\"%EA%B7%B8%EB%9E%98%EC%84%9C-%EC%96%B4%EB%94%94%EB%8B%A4-%EC%93%B0%EB%8A%94-%EA%B1%B4%EB%8D%B0\">그래서 어디다 쓰는 건데 <a class=\"direct-link\" href=\"#%EA%B7%B8%EB%9E%98%EC%84%9C-%EC%96%B4%EB%94%94%EB%8B%A4-%EC%93%B0%EB%8A%94-%EA%B1%B4%EB%8D%B0\">#</a></h2>\n<p>결론부터 말하자면 symbol은 object의 property를 숨기는 데 쓰일 <strong>예정</strong>이었다. 아래의 코드를 보자.</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><br>    id<span class=\"token operator\">:</span> <span class=\"token number\">1234</span><span class=\"token punctuation\">,</span><br>    name<span class=\"token operator\">:</span> <span class=\"token string\">\"juhojuho\"</span><span class=\"token punctuation\">,</span><br>    <span class=\"token punctuation\">[</span> <span class=\"token function\">Symbol</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"password\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">]</span><span class=\"token operator\">:</span> <span class=\"token string\">\"E9HC21\"</span><br><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><br> <br><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> key <span class=\"token keyword\">in</span> obj<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// logs \"id\" and \"name\"</span><br><span class=\"token punctuation\">}</span><br> <br>Object<span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span> obj <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// [\"id\", \"name\"]</span><br> <br>Object<span class=\"token punctuation\">.</span><span class=\"token function\">getOwnPropertySymbols</span><span class=\"token punctuation\">(</span> obj <span class=\"token punctuation\">)</span> <span class=\"token comment\">// [Symbol(password)]</span></code></pre>\n<p>이번에도 역시 신기한 결과가 나왔다.</p>\n<p><code>obj</code>를 보면 <code>password</code>의 타입이 symbol이다. 근데 <code>id</code>와 <code>name</code>과는 다르게 <code>Symbol(&quot;password&quot;)]</code> 좌우로 괄호가 있다. 둘러싸고 있는 <code>[ ]</code>는 ES6에 새로 추가된 'Computed Property' 기능인데 이는 추후 포스트에서 자세히 다루겠다. 지금은 걱정하지 말고 일단 넘어가자.</p>\n<p>이제 앞서 말했듯이 symbol로 된 property가 잘 숨겨졌는지 알아보자. 우선 <code>for..in</code>를 사용하면 보이지 않는다. <code>Object.keys()</code> 함수로도 나오지 않는다. 실제로 웬만한 방법으로는 symbol로 된 property를 찾기 힘들다. 하지만 안타깝게도 특별한 함수로 숨겨진 property를 찾을 수 있다. <code>Object.getOwnPropertySymbols()</code> 함수를 사용하면 숨겨진 property가 보인다. 위 코드의 맨 아랫줄에서 <code>[Symbol(password)]</code>가 나옴을 확인할 수 있다. 결국 '예정'이었을 뿐 ES6에서 property를 숨길 수는 없다.</p>\n<p>그럼 뭐지, 결국 symbol은 쓰잘데기 없는 것인가? 대답은 '아니요'다. symbol을 굳이 ES6에 추가한 데는 다 이유가 있다! symbol을 사용하면 property 간에 충돌을 피할 수 있다. 앞서 말했듯이 symbol은 그 자체로 유일하다. 심지어 <code>Symbol('password')</code>와 <code>Symbol('password')</code>조차도 다른 값임을 기억하자. 따라서 symbol을 이용하면 object에 중복된 property를 추가할 때 생기는 충돌을 피할 수 있다. 아래의 경우처럼 말이다. 매개변수가 같은 세 symbol 모두 충돌 없이 <code>obj</code>에 저장된다.</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><br> <br>obj<span class=\"token punctuation\">[</span><span class=\"token function\">Symbol</span><span class=\"token punctuation\">(</span><span class=\"token string\">'name'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"Moon\"</span><br>obj<span class=\"token punctuation\">[</span><span class=\"token function\">Symbol</span><span class=\"token punctuation\">(</span><span class=\"token string\">'name'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"Ahn\"</span><br>obj<span class=\"token punctuation\">[</span><span class=\"token function\">Symbol</span><span class=\"token punctuation\">(</span><span class=\"token string\">'name'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"Lee\"</span><br> <br>obj <span class=\"token comment\">// Object {Symbol(name): \"Moon\", Symbol(name): \"Ahn\", Symbol(name): \"Lee\"}</span></code></pre>\n<p>그런 경우가 실제로 있냐고 반문할 수 있다. 하지만 은근히 많이 일어나는 일이다. 예를 들어 철수가 웹 프로그래밍을 하면서 DOM element의 상태를 추적하고 싶다고 상상해 보자. 철수는 element가 유효한지 체크하기 위해 <code>isValid</code>라는 property를 모든 element에 추가했다. 흠, 보기에는 문제없다. 하지만 철수의 코드만이 DOM element를 다루는 게 아니다. 철수가 참조한 다른 라이브러리의 코드도 똑같이 DOM element를 건드린다. 철수가 추가한 <code>isValid</code> property 때문에 외부 코드가 <code>for..in</code>이나 <code>Object.keys()</code> 함수를 쓰면서 예상치 못한 결과를 맞을 수 있다. 또한, 외부 코드가 철수와 똑같이 <code>isValid</code> property를 추가할 수도 있다. 최악의 상황에 철수가 사용하는 브라우저가 추후 업데이트로 <code>isValid</code>를 모든 DOM element에 추가하면 property 간에 충돌이 일어나 문제가 발생할 수 있다. 따라서 내 코드 뿐만 아니라 다른 코드도 한 object를 다루는 상황에서 symbol이 유용하게 사용될 수 있다. 물론 이 뿐만 아니라 다른 값과 중복되지 말아야 할 고유값이 필요한 모든 경우에 symbol을 쓸 수 있다.</p>\n<h2 id=\"%ED%95%9C-%EB%B0%9C%EC%9E%90%EA%B5%AD-%EB%8D%94\">한 발자국 더 <a class=\"direct-link\" href=\"#%ED%95%9C-%EB%B0%9C%EC%9E%90%EA%B5%AD-%EB%8D%94\">#</a></h2>\n<p>간혹 한 symbol을 여러 번 사용해야 하는 경우가 있다. 혹은 여러 자바스크립트 파일이나 모듈에서 symbol을 공유해야 하는 경우도 있다. 다행히 symbol을 <strong>symbol registry</strong>에 등록하면 이 문제가 해결된다. <code>Symbol.for()</code> 함수를 이용하면 symbol registry에 등록할 수 있고, 나중에 여러 번 불러 쓰는 것도 가능하다. 불러올 때도 똑같이 <code>Symbol.for()</code> 함수를 쓰면 이전에 등록했던 symbol이 반환된다. 아래 코드를 참조하자.</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> sym1 <span class=\"token operator\">=</span> Symbol<span class=\"token punctuation\">.</span><span class=\"token function\">for</span><span class=\"token punctuation\">(</span><span class=\"token string\">'foo'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><span class=\"token keyword\">var</span> sym2 <span class=\"token operator\">=</span> Symbol<span class=\"token punctuation\">.</span><span class=\"token function\">for</span><span class=\"token punctuation\">(</span><span class=\"token string\">'foo'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br> <br>sym1 <span class=\"token operator\">===</span> sym2 <span class=\"token comment\">//true</span></code></pre>\n<p>초반에 <code>Symbol()</code> 함수의 매개변수가 단지 <em>설명</em>일 뿐이라 했는데 사실 한 가지 기능이 더 있다. 바로 symbol registry에서 매개변수는 일종의 key로 작용한다. <code>Symbol.for('foo')</code>을 여러 번 호출해도 매번 같은 symbol이 나오는 이유다.</p>\n<p>마지막으로 자바스크립트에는 여러 개의 built-in(이미 구현된) symbol이 있다. 모두 <code>Symbol()</code> 함수의 property에 달려 있다. 언젠가 다룰 <code>Symbol.iterator</code>를 포함해 각자 ES6에서 중요한 역할을 맡고 있다. 지금 당장 하나씩 설명하기보단 나올 때마다 차근차근 설명하겠다.</p>\n<p>진짜 마지막으로 자바스크립트 명세(specification)를 보면 <code>@@</code>가 보이는데, 이게 바로 built-in symbol을 나타내는 표시다. 골뱅이가 두 개라고 놀라지 말자.</p>\n<p>이 정도면 symbol에 대해 충분히 다뤘다고 생각한다. 혹시 더 궁금한 게 있다면 아래 레퍼런스를 참조하길 바란다.</p>\n<p><strong>Reference</strong><br>\n<a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol\">Symbol - JavaScript | MDN</a><br>\n<a href=\"https://hacks.mozilla.org/2015/06/es6-in-depth-symbols/\">ES6 In Depth: Symbols</a><br>\n<a href=\"https://github.com/getify/You-Dont-Know-JS/blob/master/es6%20%26%20beyond/ch2.md\">You Don't Know JS: ES6 &amp; Beyond</a></p>\n",
      "date_published": "2020-05-28T15:00:00+09:00"
    },{
      "id": "https://juhojuho.github.io/posts/js-map/",
      "url": "https://juhojuho.github.io/posts/js-map/",
      "title": "[JS] Map",
      "content_html": "<p>어떤 프로그래밍 언어로 개발하던 Map은 유용하게 사용된다. 옆 동네 Python에서 Map을 쓰는 빈도를 봐도 알 수 있다. 하지만 안타깝게도 Map은 ES6 전까지 자바스크립트에 존재하지 않았다. 대신 Object에 몇 가지 꼼수를 부리며 그 빈자리를 달랠 뿐이었다. <em>보통 Object에 연결된 prototype을 제거하기 위해 <code>Object.create(null)</code>을 이용한다. 만약 평범한 Object를 사용했다면 주렁주렁 달려 있는 property 때문에 Map에 key 삽입시 충돌이 일어날 수도 있다.</em> 이번 포스트에서는 ES6에 새롭게 추가된 데이터 구조 Map에 대해 알아보자.</p>\n<h2 id=\"google-map-%ED%95%A0-%EB%95%8C-%EA%B7%B8-map%3F\">Google Map 할 때 그 Map? <a class=\"direct-link\" href=\"#google-map-%ED%95%A0-%EB%95%8C-%EA%B7%B8-map%3F\">#</a></h2>\n<p>Map은 Object와 비슷하게 key와 value를 쌍으로 저장한다. 이때, key는 중복되지 않는다. 만약 이미 저장된 key가 또 들어오면 기존 value를 새 값으로 덮어쓴다. <code>set(key, value)</code> 함수로 key와 value를 저장하고 <code>get(key)</code>로 그 key와 연결된 value를 반환한다. 그리고 <code>new Map()</code>으로 Map을 생성한다. <code>new</code>를 쓰는 거로 보아 Map의 타입이 Object임을 알 수 있다. 마지막으로 삭제는 <code>delete(key)</code>로 하며 <code>clear()</code>로 모든 key, value 쌍을 지운다. 아래 코드에 기본적인 Map 사용법이 나와 있다.</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> myMap <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br> <br><span class=\"token keyword\">typeof</span> myMap <span class=\"token comment\">// \"object\"</span><br> <br>myMap<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">'name'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Tom'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>myMap<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">'age'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">15</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>myMap<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">'name'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Sam'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br> <br>myMap<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'name'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// \"Sam\"</span><br>myMap<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'age'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 15</span><br><br>myMap<span class=\"token punctuation\">.</span><span class=\"token function\">delete</span><span class=\"token punctuation\">(</span><span class=\"token string\">'name'</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// true</span><br>myMap<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'name'</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// undefined</span><br><br>myMap<span class=\"token punctuation\">.</span><span class=\"token function\">clear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>myMap<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'age'</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// undefined</span></code></pre>\n<h2 id=\"map%EA%B3%BC-object\">Map과 Object <a class=\"direct-link\" href=\"#map%EA%B3%BC-object\">#</a></h2>\n<p>여기까지 보면 Map은 Object와 상당히 유사하다. 그렇다면 왜 Map이 필요한 걸까? Map이 Object보다 나은 몇 가지 이유를 살펴보자.</p>\n<p>Object의 key는 반드시 String이거나 Symbol이다. <a href=\"https://juhojuho.github.io/posts/js-symbol/\">앞선 포스트</a>에서 봤듯이 ES6에서 새로 추가된 타입인 Symbol은 Object의 key로 사용될 수 있다. 반면에 Map의 key는 모든 타입을 허용한다. Number, Boolean은 물론이고 Object까지 가능하다. 즉, Object에 포함되는 function이나 array도 key로 사용할 수 있다.</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> myMap <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br> <br><span class=\"token keyword\">var</span> keyString <span class=\"token operator\">=</span> <span class=\"token string\">'string key'</span><span class=\"token punctuation\">;</span><br><span class=\"token keyword\">var</span> keyObject <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> key<span class=\"token operator\">:</span> <span class=\"token string\">'object key'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><br><span class=\"token keyword\">var</span> <span class=\"token function-variable function\">keyFunction</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> <span class=\"token string\">'function key'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><br><span class=\"token keyword\">var</span> keySymbol <span class=\"token operator\">=</span> <span class=\"token function\">Symbol</span><span class=\"token punctuation\">(</span><span class=\"token string\">'symbol key'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br> <br>myMap<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>keyString<span class=\"token punctuation\">,</span> <span class=\"token string\">'I am a string key'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>myMap<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>keyObject<span class=\"token punctuation\">,</span> <span class=\"token string\">'I am a object key'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>myMap<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>keyFunction <span class=\"token punctuation\">,</span> <span class=\"token string\">'I am a function key'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>myMap<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>keySymbol<span class=\"token punctuation\">,</span> <span class=\"token string\">'I am a symbol key'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br> <br>myMap<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>keyString<span class=\"token punctuation\">)</span> <span class=\"token comment\">// \"I am a string key\"</span><br>myMap<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>keyObject<span class=\"token punctuation\">)</span> <span class=\"token comment\">// \"I am a object key\"</span><br>myMap<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>keyFunction<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// \"I am a function key\"</span><br>myMap<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>keySymbol<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// \"I am a symbol key\"</span></code></pre>\n<p>위 코드처럼 모든 타입이 Map의 key로 사용될 수 있다.</p>\n<p>사소하지만 꽤 강력한 차이점이 하나 더 있다. Object는 크기를 구하는 built-in(이미 구현된) method나 property가 없다. <code>Object.keys(object).length</code>가 그나마 쉬운 방법이다. 하지만 time complexity가 linear하므로 Object가 커질수록 더 많은 시간이 소요된다. 반면에 Map은 <code>size</code> property로 크기를 단번에 구할 수 있다. 이 경우 <code>size</code> property가 수시로 갱신되므로 Map의 크기가 커져도 걸리는 시간에 영향을 주지 않는다.</p>\n<pre class=\"language-js\"><code class=\"language-js\">myMap<span class=\"token punctuation\">.</span>size <span class=\"token comment\">// 4</span></code></pre>\n<h2 id=\"map-%EA%B0%80%EC%A7%80%EA%B3%A0-%EC%A7%80%EC%A7%80%EA%B3%A0-%EB%B3%B6%EA%B8%B0\">Map 가지고 지지고 볶기 <a class=\"direct-link\" href=\"#map-%EA%B0%80%EC%A7%80%EA%B3%A0-%EC%A7%80%EC%A7%80%EA%B3%A0-%EB%B3%B6%EA%B8%B0\">#</a></h2>\n<p>Map에 저장된 key와 value를 쭉 늘여놓고 싶으면 <code>values()</code>와 <code>keys()</code> 함수를 사용하면 된다. 단, 이 두 함수는 iterator를 반환한다. 따라서 추가적인 작업이 들어가야 예쁘게 표현될 수 있다. 지금 단계에서 iterator를 몰라도 괜찮다. 다음 포스트에서 다룰 예정이다. 이제 아래 코드를 보자.</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> myMap <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>myMap<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>myMap<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">'b'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>myMap<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">'c'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br> <br>myMap<span class=\"token punctuation\">.</span><span class=\"token function\">values</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// MapIterator {1, 2, 3}</span><br> <br><span class=\"token punctuation\">[</span> <span class=\"token operator\">...</span>myMap<span class=\"token punctuation\">.</span><span class=\"token function\">values</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// [1, 2, 3]</span><br>Array<span class=\"token punctuation\">.</span><span class=\"token function\">from</span> <span class=\"token punctuation\">(</span> myMap<span class=\"token punctuation\">.</span><span class=\"token function\">values</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// [1, 2, 3]</span></code></pre>\n<p><code>values()</code> 함수를 사용하면 Map에 저장된 모든 value가 iterator로 반환된다. iterator를 푸는 가장 원초적인 방법은 <code>for</code>문을 쓰는 것이다. 하지만 훨씬 더 손쉬운 방법이 ES6에 존재한다. Spread operator <code>...</code> 와 새로운 Array API <code>from()</code>을 쓰면 iterator를 array로 변환시킬 수 있다. 하지만 이 부분은 이번 포스트의 범위를 넘어가므로 다음에 다루겠다. 지금은 <code>values()</code>가 value의 iterator를 반환하고 이를 푸는 새로운 방법이 ES6에 등장했다는 정도만 알고 있자. <code>keys()</code>는 key의 iterator를 반환하며 나머지는 <code>values()</code>와 비슷하게 작용한다.</p>\n<p><strong>Reference</strong><br>\n<a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Map\">Map - JavaScript | MDN</a><br>\n<a href=\"https://hacks.mozilla.org/2015/06/es6-in-depth-collections/\">ES6 In Depth: Collections</a><br>\n<a href=\"https://github.com/getify/You-Dont-Know-JS/blob/master/es6%20%26%20beyond/ch5.md\">You Don't Know JS: ES6 &amp; Beyond</a></p>\n",
      "date_published": "2020-04-29T15:00:00+09:00"
    },{
      "id": "https://juhojuho.github.io/posts/js-arrow-function/",
      "url": "https://juhojuho.github.io/posts/js-arrow-function/",
      "title": "[JS] Arrow Function",
      "content_html": "<p>ES6를 한 번이라도 접해본 사람이라면 Arrow Function을 알고 있을 것이다. Arrow Function은 코드의 수를 획기적으로 줄이고 가독성을 높인다. 단순히 문법적 편리성 뿐만 아니라 <code>this</code>의 용법도 달라진다. 이번 포스트에서 자세히 알아보자.</p>\n<p>본격적으로 들어가기 전에 간단한 퀴즈 2개를 풀어보자.</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// Quiz1</span><br><span class=\"token keyword\">var</span> foo <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token function-variable function\">a</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span><br>foo<span class=\"token punctuation\">.</span><span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// What's the output?</span><br> <br><span class=\"token comment\">// Quiz2</span><br><span class=\"token keyword\">var</span> bar <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token function-variable function\">b</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><br>        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span><br>bar<span class=\"token punctuation\">.</span><span class=\"token function\">b</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// What's the output?</span><br></code></pre>\n<p><code>foo.a()</code>와 <code>bar.b()</code>의 출력값은 무엇일까? 만약 첫 번째 문제의 답을 <code>a</code>로 구했다면 이 포스트를 읽기 전에 <code>this</code>의 용법을 다시 공부하길 추천한다. <code>foo.a()</code>는 <code>foo</code>를 출력한다. 두 번째 문제는 다소 어렵다. 만약 답을 맞힌다면 이 포스트를 읽지 않고 건너뛰어도 무방하다. 당신은 이미 Arrow Function을 마스터했다! 아마 <code>bar.b()</code>의 출력값을 <code>bar</code>로 예상했겠지만, 답은 <code>window</code>이다. 굉장히 놀랍지 않나! 이제부터 왜 그런지 Arrow Function에 하나씩 대해 알아보자.</p>\n<h2 id=\"%EB%84%98%EB%82%98-%ED%8E%B8%EB%A6%AC%ED%95%9C-%EA%B2%83\">넘나 편리한 것 <a class=\"direct-link\" href=\"#%EB%84%98%EB%82%98-%ED%8E%B8%EB%A6%AC%ED%95%9C-%EA%B2%83\">#</a></h2>\n<p>가끔 자바스크립트를 쓰다 보면 간단한 로직을 위해 생각보다 많은 코드를 쓸 때가 있다.</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span><br> <br><span class=\"token comment\">// Before ES6</span><br>arr<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token keyword\">return</span> x <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span><br><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><br><span class=\"token comment\">// ES6</span><br>arr<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> x <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span></code></pre>\n<p>배열의 모든 값을 2배 하는 간단한 코드다. 위와 아래 중 어떤 코드가 더 읽기 편한가. 물론 워낙 짧은 코드라서 둘 다 가독성이 좋다. 하지만 코드의 양이 많아질수록 syntatic sugar는 큰 도움이 된다. Arrow Function도 그런 면에서 함수를 정의하는 기존의 <code>function</code> 키워드의 대체재로써 ES6에 새로 추가되었다. Arrow Function을 쓰면 훨씬 간단하게 함수를 표현할 수 있다.</p>\n<h2 id=\"%EB%B3%B8%EA%B2%A9%EC%A0%81%EC%9C%BC%EB%A1%9C-arrow-function-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0\">본격적으로 Arrow Function 활용하기 <a class=\"direct-link\" href=\"#%EB%B3%B8%EA%B2%A9%EC%A0%81%EC%9C%BC%EB%A1%9C-arrow-function-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0\">#</a></h2>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> <span class=\"token function-variable function\">names</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token string\">'Harry'</span><span class=\"token punctuation\">;</span><br><span class=\"token keyword\">var</span> <span class=\"token function-variable function\">square</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">x</span> <span class=\"token operator\">=></span> x <span class=\"token operator\">*</span> x<span class=\"token punctuation\">;</span><br><span class=\"token keyword\">var</span> <span class=\"token function-variable function\">nothing</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">x<span class=\"token punctuation\">,</span> y</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>x <span class=\"token operator\">+</span> y<span class=\"token punctuation\">}</span><br><span class=\"token keyword\">var</span> <span class=\"token function-variable function\">printAll</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">,</span> z</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><br>    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>z<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br><span class=\"token punctuation\">}</span><br> <br><span class=\"token function\">names</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// \"Harry\"</span><br><span class=\"token function\">square</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 25</span><br><span class=\"token function\">nothing</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// undefined</span><br><span class=\"token function\">printAll</span><span class=\"token punctuation\">(</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'c'</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// logs a, b, c</span></code></pre>\n<p>Arrow Function은 <code>function</code> 키워드가 필요 없고 특정 조건에서 <code>return</code>이나 <code>{ }</code> 중괄호까지 생략할 수 있다. 단지 <code>=&gt;</code> 키워드만 필요하다. <code>=&gt;</code> 앞에는 매개변수가 있고 뒤에 함수의 본문이 위치한다.</p>\n<p>매개변수는 기존의 방식처럼 <code>( )</code> 소괄호로 감싸면 된다. 단, 매개변수가 하나면 괄호를 생략해도 된다. 매개변수가 없거나 하나 이상이면 괄호가 필요하다.</p>\n<p>body는 이전처럼 <code>{ }</code> 중괄호로 감싸면 된다. 단, body가 단 한 줄이면 생략할 수 있다. 여기서 조심해야 할 점이 있다. 중괄호를 생략하면 자동으로 <code>return</code>이 body에 삽입된다. 위 코드에서 <code>square</code> 함수가 그 예다. <code>return</code>이 없는 데도 <code>25</code>가 반환되었다. 따라서 어떤 값도 함수에서 반환하고 싶지 않으면 body가 한 줄이어도 중괄호를 생략하면 안 된다. 그 예로 위에서 <code>nothing</code> 함수는 중괄호를 삽입해 <code>25</code>가 아닌 <code>undefined</code>를 반환한다.</p>\n<h2 id=\"%EC%9D%B4%EC%A0%9C%EB%B6%80%ED%84%B0-%EB%8D%94-%EC%A4%91%EC%9A%94%ED%95%B4\">이제부터 더 중요해 <a class=\"direct-link\" href=\"#%EC%9D%B4%EC%A0%9C%EB%B6%80%ED%84%B0-%EB%8D%94-%EC%A4%91%EC%9A%94%ED%95%B4\">#</a></h2>\n<p>Arrow Function의 역할은 단순히 코드 길이를 줄이는 게 아니다. Arrow Function을 사용하면 <code>this</code>의 용법이 달라진다.</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> foo <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token function-variable function\">bar</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>        <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span><br><br>foo<span class=\"token punctuation\">.</span><span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// logs window</span></code></pre>\n<p>보통 <code>this</code>는 동적으로 정해진다. run-time에 결정되므로 코드만 봐서는 <code>this</code>가 어떤 값일지 모른다. 어떤 문맥(context)에서 <code>this</code>가 호출되는지 잘 살펴봐야 한다. 위 예처럼 callback function은 window가 호출하므로 <code>this</code>는 window를 가리킨다.</p>\n<p>하지만 Arrow function을 사용하면 <code>this</code>가 정적으로 정해진다. 그래서 코드만 잘 살펴봐도 <code>this</code>에 어떤 값이 들어갈지 쉽게 유추할 수 있다. Arrow function에서 <code>this</code>는 한 단계 밖 scope의 <code>this</code>와 일치한다. 쉽게 말하면 <code>this</code>를 평범한 변수 취급하라는 얘기다. 즉, <code>this</code>를 Arrow Function 내부에는 존재하지 않는 변수여서 한 단계 위의 <code>this</code>를 가져온다고 생각하면 편하다. 마치 아래 코드에서 변수 <code>a</code>가 하듯이 말이다.</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello World!\"</span><span class=\"token punctuation\">;</span><br>    <span class=\"token keyword\">function</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><br>    <span class=\"token punctuation\">}</span><br>    <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span><br> <br><span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// logs \"Hello World!\"</span></code></pre>\n<p>함수 <code>bar</code> 내부에 변수 <code>a</code>가 존재하지 않아 자바스크립트 엔진은 한 단계 위 scope(이 경우 함수 <code>foo</code>)에서 <code>a</code>가 있는지 찾는다. 따라서 함수 <code>foo</code> 내부의 <code>a</code>가 출력된다. Arrow Function 속에 있는 <code>this</code>는 변수 <code>a</code>와 비슷하게 작동한다. 이제 실제 예를 보며 <code>this</code> 찾기를 연습해보자.</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> foo <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token function-variable function\">bar</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>        <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><br>            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span><br> <br>foo<span class=\"token punctuation\">.</span><span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// logs foo</span></code></pre>\n<p>위의 코드에서 <code>console.log(this)</code>의 한 단계 밖 scope는 <code>bar</code>이다. 즉, Arrow function의 내부에서 <code>this</code>는 <code>bar</code>에서의 <code>this</code>와 일치한다. <code>bar</code>에서 <code>this</code>는 <code>foo</code>를 가리키므로 Arrow function 내부에서 <code>this</code>도 <code>foo</code>를 가리킨다.</p>\n<p>혹시 이해가 가지 않는다면 아래의 코드를 참고하자. 위의 코드를 그대로 풀어쓰면 아래의 코드가 나온다.</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> foo <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token function-variable function\">bar</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>        <span class=\"token keyword\">var</span> self <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span><br>        <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span><br> <br>foo<span class=\"token punctuation\">.</span><span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">//logs foo</span></code></pre>\n<p>위 코드는 우리가 흔히 callback function에서 <code>this</code>를 정의할 때 주로 쓰는 패턴이다. callback function을 누가 호출할지 예측할 수 없으므로 우린 <code>this</code>에 직접 값을 대입해준다. 이 경우 <code>bar</code>의 <code>this</code>를 변수 <code>self</code>에 담아 callback function으로 전해줬다. Arrow Function가 <code>var self = this;</code>를 대체한다고 생각하면 편한다.</p>\n<p>이제 맨 위의 퀴즈도 자연스레 풀 수 있을 것이다.</p>\n<pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// Quiz2</span><br><span class=\"token keyword\">var</span> bar <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token function-variable function\">b</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><br>        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span> <br> <br>bar<span class=\"token punctuation\">.</span><span class=\"token function\">b</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// logs window</span></code></pre>\n<p><code>console.log(this)</code>가 속한 Arrow function의 한 단계 밖 함수는 <code>b</code>이다. <code>b</code>에서 <code>this</code>는 window(global object)를 가리킨다. 따라서 <code>console.log(this)</code>의 <code>this</code>도 window를 가리키게 된다.</p>\n<p>이런 <code>this</code>의 의미를 변화를 이해하지 않으면 우리가 의도했던 바와 다르게 프로그램이 동작할 수 있다. Arrow Function은 결코 문법적 편리성만 제공하지 않는다! 바뀌는 <code>this</code>의 용법 반드시 이해하자.</p>\n<p>매번 느끼는 거지만 아는 것을 말로 풀어내기는 참 힘들다. 특히 코딩 관련 지식을 글로 풀어내긴 더 힘든 것 같다. 이번 포스트는 내가 봐도 독자가 이해하기 어려울 것 같다(ㅠ_ㅠ). 혹시 이해 가지 않은 부분이 있으면 꼭 댓글로 달아주길 바란다. 그 부분에 대해 더 자세히 설명해 주겠다.</p>\n",
      "date_published": "2019-07-31T15:00:00+09:00"
    },{
      "id": "https://juhojuho.github.io/posts/new-language-translation/",
      "url": "https://juhojuho.github.io/posts/new-language-translation/",
      "title": "[번역] 새로운 언어를 배우는 &#39;흔치 않은&#39; 방법",
      "content_html": "<p>나는 적어도 1년에 한 번 새로운 언어를 배운다. 그리고 어떻게 하면 빨리 익힐 수 있을까 늘 고민한다. 개인적으로는 공식 사이트에서 언어 spec을 읽고 실제 개인 프로젝트에 적용하며 시행착오를 겪으며 새로운 언어를 배운다. Medium에 새로운 언어를 배우는 방법과 관련해 흥미로운 글이 올라왔길래 미약한 실력으로나마 번역해 보았다. 원문은 <a href=\"http://hackernoon.com/@sahildua2305\">Sahil Dua</a>의 <a href=\"http://hackernoon.com/unconventional-way-of-learning-a-new-programming-language-e4d1f600342c#.gmrl9tuk3\">Unconventional way of learning a new programming language</a>이다. 오역과 의역이 난무하니 영어가 익숙한 분들은 링크를 타고 원문을 읽길 바란다.</p>\n<hr>\n<p>세상에는 500개 이상의 프로그래밍 언어가 있습니다. 그래서 개발자는 항상 새로운 언어를 배워야 합니다. 우리는 다양한 상황에서 새로운 언어와 맞닥뜨리게 됩니다. 가령 C++과 Java를 능숙하게 다루지만 정작 직장에선 Python으로 개발해야 하는 경우가 있겠죠. 또는 단순히 실력 향상과 호기심 때문에 새로운 언어를 배울 수도 있습니다.</p>\n<p>그럼 여기서 질문. 여러분은 새로운 언어를 어떻게 배우나요?</p>\n<ul>\n<li>온라인 튜토리얼을 이용한다.</li>\n<li>Coursera 같은 MOOC 강의를 이용한다.</li>\n</ul>\n<p>혹은 이렇게 배우는 사람들도 있겠죠.</p>\n<ul>\n<li>새로운 언어의 문법을 익힌다.</li>\n<li>그 언어를 개인 프로젝트에 활용한다.</li>\n</ul>\n<p>모두 훌륭한 방법입니다!</p>\n<p>저는 새로운 언어를 배우면서 20개 이상의 작은 프로젝트를 진행했습니다. 그 프로젝트 중에는 1주일짜리도 있었고 하룻밤 사이에 완성되는 겁나 짧은 프로젝트도 있었습니다. 저뿐만 아니라 여러분도 늘 그 과정에서 코드가 어떻게든 작동하는 데만 집중할 겁니다. '이 코드가 잘 작동할까?'만이 안중에 있죠. 그래서 코드의 질은 늘 뒷전으로 밀려납니다.</p>\n<blockquote>\n<p>어떤 바보도 컴퓨터가 이해하도록 코드를 작성할 수 있다. 좋은 개발자는 인간도 이해할 수 있는 코드를 쓴다. - Martin Fowler</p>\n</blockquote>\n<p>이제 새로운 언어를 배우는 저만의 비법을 소개하겠습니다.</p>\n<h2 id=\"%EA%B7%B8-%EC%96%B8%EC%96%B4%EB%A1%9C-%EC%9E%91%EC%84%B1%EB%90%9C-%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90-%EA%B8%B0%EC%97%AC(contribute)%ED%95%98%EB%9D%BC\">그 언어로 작성된 오픈소스 프로젝트에 기여(contribute)하라 <a class=\"direct-link\" href=\"#%EA%B7%B8-%EC%96%B8%EC%96%B4%EB%A1%9C-%EC%9E%91%EC%84%B1%EB%90%9C-%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90-%EA%B8%B0%EC%97%AC(contribute)%ED%95%98%EB%9D%BC\">#</a></h2>\n<p>놀랐나요? 아마도 이렇게 반문할 거에요. &quot;잠깐, 오픈 소스는 어려운 거 아닌가요? 그 언어의 전문가가 돼야만 오픈소스에 기여할 수 있잖아요&quot;. 하지만 실제로는 그렇지 않습니다.</p>\n<p>제 얘기를 들려 드릴게요.</p>\n<p>저는 작년에 Booking.com에 스카우트되었습니다. 그 회사는 백엔드 언어로 Perl을 사용하고 있었습니다. 전 2016년 6월 대학을 졸업하면서 제 첫 직장 생활에 대비해 Perl을 공부하기 시작했습니다. 7월 둘째 주에 첫 출근이 잡혀있던 터라 제게는 약 1달간의 시간밖에 없었습니다.</p>\n<p>전 Perl의 문법을 공부하고 몇 가지 흔한 패턴을 이해하기 시작했습니다. 곧 Perl을 프로젝트에 실제로 사용해 보면서 제가 배웠던 문법과 패턴을 활용해 보고 싶은 마음이 생겼습니다. Perl로 개발해 볼 만한 것들을 찾던 도중 GitHub에서 DuckDuckGo의 오픈소스 그룹을 찾게 되었습니다. 거기서 몇몇 프로젝트는 Perl을 사용하고 있었습니다. 등록된 이슈를 살펴보던 도중 꽤 많은 &quot;초보자&quot; 이슈가 있다는 걸 발견했습니다. 전 즉시 몇 개의 이슈를 맡아 해결했고 pull request를 날렸습니다. 지금에 이르러 저는 DuckDuckGo의 메인 기여자가 되었으며 Open Source Community Leader 중 한 명이 되었습니다.</p>\n<blockquote>\n<p>한줄요약 - 나는 Perl로 작성된 오픈소스 프로젝트에 참여하면서 Perl을 배웠다.</p>\n</blockquote>\n<h2 id=\"%EC%A0%95%EB%A7%90%EB%A1%9C-%EC%9D%B4-%EB%B0%A9%EB%B2%95%EC%9D%B4-%ED%9A%A8%EA%B3%BC%EA%B0%80-%EC%9E%88%EB%82%98%EC%9A%94%3F\">정말로 이 방법이 효과가 있나요? <a class=\"direct-link\" href=\"#%EC%A0%95%EB%A7%90%EB%A1%9C-%EC%9D%B4-%EB%B0%A9%EB%B2%95%EC%9D%B4-%ED%9A%A8%EA%B3%BC%EA%B0%80-%EC%9E%88%EB%82%98%EC%9A%94%3F\">#</a></h2>\n<p>저는 Perl의 문법을 배우자마자 오픈소스 프로젝트에 기여했습니다. 그러면서 프로젝트의 코드를 읽으며 자연스레 perl의 기본적인 패턴을 배웠습니다. 기존 코드에 있던 좋은 점들을 제 코드에 녹여내기 시작했고 그것은 제가 Perl로 좋은 코드를 쓰는 데 도움이 되었습니다.</p>\n<p>그건 결코 우연이 아니었습니다. 여러분께 확신을 주기 위해 이와 비슷한 이야기를 하나 더 해보죠.</p>\n<p>최근 Booking.com에서 일하면서 Go로 작성된 몇 가지 서비스 개발에 참여할 기회를 얻게 되었습니다. 다음은 제 동료와 나눈 대화입니다.</p>\n<blockquote>\n<p>나: 그 프로젝트 정말 괜찮더라~ 나도 참여하고 싶어. 나도 낄 수 있을까?<br>\n동료: 물론이지. 네가 관심만 있다면. 근데 너 Go 쓸 줄 알아?<br>\n나: 당연 모르지(데헷&gt;&lt;)<br>\n동료: 그럼 Go 배우고는 싶어?<br>\n나: 당근이지!<br>\n동료: (방긋) 그럼 같이 해보자!</p>\n</blockquote>\n<p>저는 그렇게 해서 새로운 언어 Go에 뛰어들게 되었습니다.</p>\n<p>저는 Go의 문법을 배우기 시작했고 Go의 공식 웹사이트에서 꽤 괜찮은 초보자를 위한 튜토리얼을 발견했습니다. 제가 Go의 기본 개념에 친숙해지는 데 충분했습니다.</p>\n<p>저는 다시 한번 Go의 오픈소스 프로젝트 중에서 '초보자'나 '고치기 쉬운' 이슈를 찾기 시작했습니다. 그러던 도중 Gihub's RESTful API의 Go wrapper를 다루는 프로젝트를 발견했고 바로 참여했습니다.</p>\n<p><strong>전 Go를 배우기 시작한 지 이틀 만에 첫 Pull Request를 넣었습니다</strong></p>\n<h2 id=\"%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%84%EC%9B%80%EC%9D%B4-%EB%90%98%EB%82%98%EC%9A%94%3F\">오픈소스는 어떻게 도움이 되나요? <a class=\"direct-link\" href=\"#%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%84%EC%9B%80%EC%9D%B4-%EB%90%98%EB%82%98%EC%9A%94%3F\">#</a></h2>\n<p>이쯤 되면 새로운 언어를 배우는 데 왜 오픈소스가 도움되는지 궁금할 거에요. 몇 가지 이유가 있습니다. 하나씩 알아보죠.</p>\n<h3 id=\"%EC%BD%94%EB%93%9C%EC%9D%98-%EC%A7%88\">코드의 질 <a class=\"direct-link\" href=\"#%EC%BD%94%EB%93%9C%EC%9D%98-%EC%A7%88\">#</a></h3>\n<p>대부분의 오픈소스 프로젝트에는 엄격한 코딩 가이드라인이 존재합니다. 당신의 코드가 merge 되긴 위해선 반드시 숙지해야 할 내용입니다. 여러분은 막 언어를 배우기 시작했음에도 그 가이드라인을 따르면서 양질의 코드를 작성할 수 있게 됩니다. 그것뿐만 남들이 쓴 코드를 보면서 어떤 코드가 잘 쓴 코드이고 어떻게 문서화해야 하는지 알 수 있습니다.</p>\n<h3 id=\"%EC%BD%94%EB%93%9C-%EB%A6%AC%EB%B7%B0\">코드 리뷰 <a class=\"direct-link\" href=\"#%EC%BD%94%EB%93%9C-%EB%A6%AC%EB%B7%B0\">#</a></h3>\n<p>오픈소스 기여의 가장 큰 장점은 코드 리뷰입니다. 당신이 코드를 푸쉬할 때마다 그 프로젝트의 전문가에게 피드백을 받을 수 있습니다. 그런 과정을 통해 언어에 대한 당신의 이해를 높일 수 있습니다. 이것은 마치 시니어 개발자에게 무료 개인과외를 받는 셈입니다!</p>\n<h3 id=\"%EB%A7%88%EC%9D%8C-%EC%A2%8B%EC%9D%80-%EC%82%AC%EB%9E%8C%EB%93%A4\">마음 좋은 사람들 <a class=\"direct-link\" href=\"#%EB%A7%88%EC%9D%8C-%EC%A2%8B%EC%9D%80-%EC%82%AC%EB%9E%8C%EB%93%A4\">#</a></h3>\n<p>우리는 소프트웨어 개발자로서 서로의 작업을 격려하고 응원해 줘야 합니다. 오픈 소스 커뮤니티는 그런 개발자에게 최적의 장소입니다. 저는 오픈소스에 기여하는 내내 모욕적이거나 제 의욕을 꺾는 코멘트를 단 한 번도 받은 적이 없습니다. 모두 친절하고 의욕이 넘칩니다.</p>\n<hr> \n<p>다음에 새로운 언어를 배울 기회가 있다면 오픈소스에 뛰어드세요! 그러면서 새로운 언어를 빠르게 익혀보세요 ;)</p>\n",
      "date_published": "2017-10-25T15:00:00+09:00"
    },{
      "id": "https://juhojuho.github.io/posts/why-elixir-is-god-language/",
      "url": "https://juhojuho.github.io/posts/why-elixir-is-god-language/",
      "title": "[번역] 큰 잠재력을 가진 언어, Elixir",
      "content_html": "<p>함수형 언어 Elixir와 웹 프레임워크 Phoenix는 최근해외에서 크게 인기를 끌고 있는 핫한 놈들입니다. Elixir는 Ruby, Clojure, Erlang의 영향을 받았으며 Erlang의 가상 머신에서 돌아갑니다. Erlang이 가진 함수형 언어의 이점을 가져 오면서 프로그래머가 코딩하는 데 불편한 여러 포인트를 보완한 신생 언어입니다. 2011년에 처음 선보였지만 함수형 언어로 프로그래밍 언어 패러다임이 넘어가는 트렌드에 맞춰 빠르게 성장하고 있습니다. Elixir가 이처럼 재빨리 유명해진 이유에는 Phoenix의 역할도 큽니다. Phoenix는 Ruby On Rails의 코어 개발자가 만든 서버 사이드 웹 프레임워크입니다. ROR의 저조한 성능에 실망한 개발자들의 강력 대안(<em>Phoenix 1.3 버젼 들어와서 ROR의 패턴과 점점 멀어지고 있긴 합니다.</em>)으로 떠오르며 최근 유명세를 얻고 있습니다. Reddit에 올라온 2017년에 새로 배우고 싶은 기술 스택이 무엇이냐는 질문에 절반 이상이 Elixr와 Phoenix를 선택하기도 했습니다. 그만큼 엄청난 포텐셜을 가진 조합입니다. 저도 아직 초보 Elixir 개발자지만 배울수록 신기하고 배울 맛 나는 감질나는 언어입니다. 이 글은 Elixir에 대한 overview로 적합하다 생각해 번역했습니다. 원문은 <a href=\"http://adrian-philipp.com/about/\">Adrian Philipp</a>의 <a href=\"http://adrian-philipp.com/post/why-elixir-has-great-potential\">Why the Elixir language has great potential</a>입니다.</p>\n<hr>\n<p>지난 몇 주간 저를 바쁘게 한 기며술이 있습니다. 바로 Elixir 언어입니다. 제 주력 언어는 PHP와 Javascript입니다. 동적이고 함수적이고 불변하고 동시성과 패턴 매칭을 지원하는 프로그래밍 언어를 배우는 일은 mind bending이었습니다. Elixir는 모던 언어일 뿐만 아니라..</p>\n<h3 id=\"1.-erlang%EC%9C%BC%EB%A1%9C-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%90%9C%EB%8B%A4.\">1. Erlang으로 컴파일된다. <a class=\"direct-link\" href=\"#1.-erlang%EC%9C%BC%EB%A1%9C-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%90%9C%EB%8B%A4.\">#</a></h3>\n<p>치열한 검증을 거쳐온 Erlang VM에서 돌아가는 선택은 탁월했습니다. 이미 동시성, 분산, falut tolerance을 이미 지원하기 떄문입니다. Elixir을 배우기 전까지 Erlang VM이 얼마나 다재다능하고 기술 스택을 간단화시키는지 알지 못했습니다.</p>\n<h3 id=\"2.-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EC%9D%98-%EC%A7%88\">2. 라이브러리의 질 <a class=\"direct-link\" href=\"#2.-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EC%9D%98-%EC%A7%88\">#</a></h3>\n<p>For all my needs so far, I found some library. 라이브러리의 질과 성숙함은 절 놀라게 했습니다. 웹 프레임워크 Phoenix, 데이터베이스 추상화 라이브러리 Ecto, GraphQL 라이브러리 Absinthe. 더 많은 라이브러리 패키지 매니져 hex에서 찾을 수 있습니다.</p>\n<h3 id=\"3.-%ED%99%95%EC%83%81%EC%9D%84-%EC%9C%84%ED%95%9C-path\">3. 확상을 위한 Path <a class=\"direct-link\" href=\"#3.-%ED%99%95%EC%83%81%EC%9D%84-%EC%9C%84%ED%95%9C-path\">#</a></h3>\n<p>premature 최적화는 비쌉니다. 빠르고 더러운 작업에 위한 재작성도 마찬가지입니다. Message passing과 process 떄문에 큰 어플로의 확장은 쉽습니다.</p>\n<h3 id=\"4.-reliability-and-resilience\">4. Reliability and resilience <a class=\"direct-link\" href=\"#4.-reliability-and-resilience\">#</a></h3>\n<p>다른 언어의 process와는 다르게 Erlang의 process는 죽어도 모든 프로세스를 스탑시키지는 않습니다. 만약 프로세스가 죽으면 supervisor가 살려냅니다. supervision 트리에서 어플을 관리하면 프로세스가 죽어도 잘 돌아가는 reliable 시스템을 만들 수 있습니다. Erlang은 <a href=\"http://verraes.net/2014/12/erlang-let-it-crash/\">Let It Crash</a> 철학을 표방합니다.</p>\n<h3 id=\"5.-%EC%84%B1%EB%8A%A5\">5. 성능 <a class=\"direct-link\" href=\"#5.-%EC%84%B1%EB%8A%A5\">#</a></h3>\n<p>Elixir/Erlang의 성능에 만족하고 있습니다.<br>\n<a href=\"https://medium.com/@Pinterest_Engineering/introducing-new-open-source-tools-for-the-elixir-community-2f7bb0bb7d8c\">수백만분의 일초의 리스펀스 타임</a>과 <a href=\"http://www.phoenixframework.org/blog/the-road-to-2-million-websocket-connections\">2백만개의 웹소켓 하나의 서버에 연결하기</a>을 읽다보면 성능 관련해서는 거정할 필요가 전혀 없습니다.<br>\n특히 PHP와 비교하면 Elixir의 성능은 더욱 두드러집니다. 엄청 많은 웹소켓 커넥션도 무난히 견디는 짱짱은 웹과 모바일 유저에게 색다른 UX를 제공합니다. Elixir와 GraphQL의 콜라보가 기다려집니다.</p>\n<h3 id=\"6.-%EA%B8%B0%EC%97%85%EC%97%90%EC%84%9C-%EC%A0%81%EC%9A%A9\">6. 기업에서 적용 <a class=\"direct-link\" href=\"#6.-%EA%B8%B0%EC%97%85%EC%97%90%EC%84%9C-%EC%A0%81%EC%9A%A9\">#</a></h3>\n<p>비록 Elixir가 신생 언어지만 Pinterest, Bleacher Report, Brightcove 등등의 곳에서 사용하고 있습니다.</p>\n<h2 id=\"elixr%EC%9D%84-%EB%B0%B0%EC%9A%B0%EB%8A%94-%ED%8C%81\">Elixr을 배우는 팁 <a class=\"direct-link\" href=\"#elixr%EC%9D%84-%EB%B0%B0%EC%9A%B0%EB%8A%94-%ED%8C%81\">#</a></h2>\n<p>그동안 객체 지향 언어만 배워왔다면 그동안 익힌 배턴을 버리기 쉽지 않았습니다. 하지만 충분히 가치있는 일입니다. 어떻게 시작해야 하나요?</p>\n<p>전 screencasts의 골수팬입니다. 코드를 보는 동시에 설명을 듣는 콜라보를 굉장히 좋아합니다. 운 좋게도 Elixir와 Phoenix에 대한 좋은 screencast 시리즈가 있습니다.</p>\n<h2 id=\"the-elixir-language\">The Elixir Language <a class=\"direct-link\" href=\"#the-elixir-language\">#</a></h2>\n<blockquote>\n<p>Q. 왜 함수형 언어를 쓰는 개발자는 자녀를 홈스쿨링 시킬까?<br>\nA. 왜냐하면 class를 싫어하므로 ㅋㅋ;;</p>\n</blockquote>\n<p>Elixir의 창시자는 잘 알려진 루비 덕후 Jose Vlim입니다. Elixir는 Ruby에 영향을 받아기 때문에 가독성이 높습니다. 이 포스트에선 언어 스펙을 자세히 다루지는 않겠습니다. 이미 많은 사람들이 저보다 훨씬 훌륭하게 다뤘습니다.</p>\n<p>제가 강조하고픈 Elixir의 유용성은 pipe 연산자입니다. |&gt;는 unix에서 처럼 작동하며 함수 A의 리턴 값을 함수 B의 매개변수로 넣어줍니다. <code>b(a())</code> 요렇게 쓰는 대신 <code>a() |&gt; b()</code> 요렇게 쓸 수 있습니다.</p>\n<p>이외에도 마음에 드는 점이 있습니다. 패턴 매칭이라던가.. Stream 모듈이라던가.. 매크로나 프로토콜 같은 extensibility라던가.. 마크다운 포맷을 위한 문서화라던가..(진짜 신세계..)</p>\n<h2 id=\"elixir%EC%9D%98-%EB%AF%B8%EB%9E%98%3F\">Elixir의 미래? <a class=\"direct-link\" href=\"#elixir%EC%9D%98-%EB%AF%B8%EB%9E%98%3F\">#</a></h2>\n<p>누가 알겠어요. 제가 판단하기로 Elixir는 신생 언어지만 주류가 될 수 있는 잠재성이 있습니다. Elixir를 쓰면 빠르게 믿을 수 있는 높은 생산성의 동시성 어플리케이션을 만들 수 있습니다. 전 2017년에 적어도 몇 가지 소규모 프로젝트에 Elixir를 사용할 계획입니다.</p>\n",
      "date_published": "2017-09-06T15:00:00+09:00"
    },{
      "id": "https://juhojuho.github.io/posts/hexo-tip/",
      "url": "https://juhojuho.github.io/posts/hexo-tip/",
      "title": "hexo 기반 블로그에 꿀기능 추가하기",
      "content_html": "<p><a href=\"https://hexo.io\">hexo</a>는 static site generator다. 쉽게 말해서 블로그 만드는 라이브러리라 생각하면 된다. Ruby 기반의 Jekyll과 함께 커스텀 블로그 계의 양대산맥으로 군림하고 있다. 그 자체만으로 굉장히 강력한 기능을 제공하지만 몇 가지 설정과 플러그인을 추가해 주면 편하게 블로그를 운영할 수 있다. 아래는 아름다운 블로그를 위한 꿀팁들이다.</p>\n<h2 id=\"themes\">Themes <a class=\"direct-link\" href=\"#themes\">#</a></h2>\n<p>우선 내 블로그를 좀 더 멋지게 꾸며본다. 기본 theme인 <a href=\"https://github.com/hexojs/hexo-theme-landscape\">landscape</a>도 좋지만 솔직히 말해서 별 기능은 없다. <a href=\"https://hexo.io/themes/\">여기</a>에 hexo에서 제공하는 모든 theme 목록이 있다. 어떤 theme은 단순히 레이아웃 변화 외에도 disqus 등의 댓글 시스템이나 google analytics 같은 기능을 블로그에 손쉽게 적용할 수 있게 도와준다. 쇼핑하는 마음으로 서너 개 골라서 직접 블로그에 적용시켜 보자.</p>\n<h2 id=\"markdown\">Markdown <a class=\"direct-link\" href=\"#markdown\">#</a></h2>\n<p>Markdown를 사용하면 귀찮게 html tag로 열고 닫지 않아도 손쉽게 웹 템플릿을 생성할 수 있다. hexo도 기본으로 Markdown renderer를 제공하지만 그 기능은 매우 제한적이다. 주석도 못 달고 heading에 자동으로 anchor tag도 안 달아준다. 좀 더 풍부한 기능을 사용하기 위해 <a href=\"https://github.com/celsomiranda/hexo-renderer-markdown-it\">hexo-renderer-markdown-it</a> 플러그인을 사용하자. <a href=\"https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki/Getting-Started\">설치 과정</a>을 마친 후에 <code>_config.yml</code>에 마크다운 설정을 추가해 주자. 내가 사용하고 있는 설정은 다음과 같다.</p>\n<pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">markdown</span><span class=\"token punctuation\">:</span><br>  <span class=\"token key atrule\">render</span><span class=\"token punctuation\">:</span><br>    <span class=\"token key atrule\">html</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span><br>    <span class=\"token key atrule\">xhtmlOut</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">false</span><br>    <span class=\"token key atrule\">breaks</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span><br>    <span class=\"token key atrule\">linkify</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span><br>    <span class=\"token key atrule\">typographer</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span><br>    <span class=\"token key atrule\">quotes</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'“”‘’'</span><br>  <span class=\"token key atrule\">plugins</span><span class=\"token punctuation\">:</span><br>    <span class=\"token punctuation\">-</span> markdown<span class=\"token punctuation\">-</span>it<span class=\"token punctuation\">-</span>abbr<br>    <span class=\"token punctuation\">-</span> markdown<span class=\"token punctuation\">-</span>it<span class=\"token punctuation\">-</span>footnote<br>    <span class=\"token punctuation\">-</span> markdown<span class=\"token punctuation\">-</span>it<span class=\"token punctuation\">-</span>ins<br>    <span class=\"token punctuation\">-</span> markdown<span class=\"token punctuation\">-</span>it<span class=\"token punctuation\">-</span>sub<br>    <span class=\"token punctuation\">-</span> markdown<span class=\"token punctuation\">-</span>it<span class=\"token punctuation\">-</span>sup</code></pre>\n<h2 id=\"rss\">RSS <a class=\"direct-link\" href=\"#rss\">#</a></h2>\n<p>RSS는 간단히 말해서 웹 구독 시스템이다. 우리가 매일 아침 신문을 받아보듯 내가 등록한 사이트에 새 글이 올라오면 자동으로 나에게 일러준다. 내가 RSS xml 파일을 블로그에 올려두면 구독자의 RSS reader가 그 파일을 긁어가는 시스템이다. 따라서 내가 새 글을 올려도 xml 파일을 업데이트해주지 않으면 구독자에게 알림이 가지 않는다. 굉장히 귀찮은 작업이다. 다행히도 <a href=\"https://github.com/hexojs/hexo-generator-feed\">hexo-generator-feed</a> 플러그인을 사용하면 xml 파일을 자동으로 생성해 준다. 이 역시 설치 후 _config.yml에 설정을 추가해야 한다. 다음은 내가 사용하고 있는 설정이다.</p>\n<pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">feed</span><span class=\"token punctuation\">:</span><br>  <span class=\"token key atrule\">type</span><span class=\"token punctuation\">:</span> atom<br>  <span class=\"token key atrule\">path</span><span class=\"token punctuation\">:</span> atom.xml<br>  <span class=\"token key atrule\">limit</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">false</span><br>  <span class=\"token key atrule\">hub</span><span class=\"token punctuation\">:</span><br>  <span class=\"token key atrule\">content</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span></code></pre>\n<h2 id=\"custom-domain\">Custom Domain <a class=\"direct-link\" href=\"#custom-domain\">#</a></h2>\n<p>Github pages를 이용하면 손쉽게 포스트를 발행할 수 있다. 하지만 안타깝게도 도메인이 길어진다. 뒤에 github.io가 붙는다. 어우 거추장스러워~ 다행히도 나만의 도메인을 사용할 수도 있다. 아래의 순서를 따라가자. 아래의 과정은 Github pages 사용자에게만 유효하다.</p>\n<ol>\n<li>먼저 도메인을 구입하자. 내 도메인의 경우 juhojuho.com이다.</li>\n<li>record 몇 개를 추가해 줘야 한다. 내가 도메인을 구입한 곳에서 record 관리 창에 들어간다. 다음의 IP 주소로 A record 2개를 생성한다.\n<blockquote>\n<p>192.30.252.153<br>\n192.30.252.154</p>\n</blockquote>\n</li>\n<li>블로그 github repo의 <code>Settings</code>에서 'Custom domain' 칸에 내 도메인을 입력하고 저장 버튼을 누른다.</li>\n<li>마지막으로 CNAME 파일을 추가해야 한다. 내 hexo blog의 루트 폴더에 있는 public 폴더에 CNAME 파일을 생성한다. 그리고 내 도메인을 입력하자. www나 http:// 빼고 오직 도메인만 입력하자.</li>\n</ol>\n<p>이외에도 도메인 설정을 더 추가할 수 있지만 이 포스트 성격에 맞지 않다 생각해서 이 정도로 줄였다. 더 많이 알고싶다면 <a href=\"https://help.github.com/articles/using-a-custom-domain-with-github-pages/\">이 포스트</a>를 참조하자.</p>\n<h2 id=\"more\">More <a class=\"direct-link\" href=\"#more\">#</a></h2>\n<p>사실 대부분의 꿀기능은 이미 hexo의 공식 웹사이트에 적혀 있다. 위에 적은 것들은 하나의 가이드라인이자 개인적으로 추천하는 플러그인일 뿐이다. 더 많은 꿀기능을 원한다면 <a href=\"https://hexo.io/plugins/\">이곳</a>을 방문하자.</p>\n",
      "date_published": "2017-04-26T15:00:00+09:00"
    }
  ]
}
