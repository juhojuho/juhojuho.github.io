<!doctype html>
<html lang="en">
  <head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-177518541-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-177518541-1');
</script>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[JS] Garbage collection</title>
    <meta name="description" content="학부 시절 운영체제 수업에서 C언어로 OS를 직접 구현하다보면 간혹 메모리가 부족하다는 버그가 뜨곤 했다. 보통 메모리 누수(memory leakage) 때문인데 메모리를 할당(e.g., malloc)하고 나중에 할당 해제(e.g., free)를 하지 않아 불필요한 메모리가 계속 쌓여 발생한다. C 같은 low-level 언어는 프로그래머가 직접 메모리를 관리할 수 있다. 하지만 JS나 Python 같은 대부분의 high-level 언어는 개발자가 임의로 메모리를 관리하는 기능을 제공하지 않는다. ">
    <meta name="google-site-verification" content="l1HzNpcuiOpfuOSg2r-oNIA3H7Csyir1J6Ndxn58yBg" />
    <link rel="icon" type="image/png" href="/img/favicon.png"/>
    <link rel="stylesheet" href="/css/index.css">
    <link rel="stylesheet" href="/css/prim-dracula.css">
    <link rel="alternate" href="/feed/feed.xml" type="application/atom+xml" title="햄스터 갬성 블로그">
    <link rel="alternate" href="/feed/feed.json" type="application/json" title="햄스터 갬성 블로그">
  </head>
  <body>
    <header>
      <h1 class="home"><a href="/">햄스터 갬성 블로그</a></h1>
      <ul class="nav">
        <li class="nav-item"><a href="/">Home</a></li>
      </ul>
    </header>

    <main class="tmpl-post">
      <h1>[JS] Garbage collection</h1>

<p>학부 시절 운영체제 수업에서 C언어로 OS를 직접 구현하다보면 간혹 메모리가 부족하다는 버그가 뜨곤 했다. 보통 메모리 누수(memory leakage) 때문인데 메모리를 할당(e.g., malloc)하고 나중에 할당 해제(e.g., free)를 하지 않아 불필요한 메모리가 계속 쌓여 발생한다. C 같은 low-level 언어는 프로그래머가 직접 메모리를 관리할 수 있다. 하지만 JS나 Python 같은 대부분의 high-level 언어는 개발자가 임의로 메모리를 관리하는 기능을 제공하지 않는다. 흠, 그럼 high-level 언어는 메모리 누수 발생을 어떻게 막는 걸까? 이 역할을 하는 게 가비지 컬렉터(Garbage colletor)이다. 가비지 컬렉터는 필요 없어진 메모리를 자체적으로 판단해 할당을 해제하여 메모리 누수의 발생을 막는다. V8 같은 JS 엔진에도 가비지 컬렉션이 구현되어 있다. Garbage collection을 한국어로 검색해보니 &quot;쓰레기 수집&quot;이라고 뜨는데 어감이 참.. 하여튼 JS에 가비지 컬렉션이 어떻게 구현되어 있는지 알아보자!</p>
<h2 id="%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0">메모리 누수 관리하기 <a class="direct-link" href="#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0">#</a></h2>
<p>메모리 누수는 프로그램이 더이상 사용하지 않는 메모리가 OS에 의해 free memory로 반환되지 않는 현상을 가르킨다. 각 프로그래밍 언어마다 메모리를 제어하는 저마다의 방식을 가지고 있다. 보통 프로그래밍 언어 입장에서 메모리가 실제 필요한지 아닌지 파악하기는 힘들다. 현재 메모리에 저장된 값을 사용되고 있지 않더라도 개발자가 추후 사용할 수도 있기 떄문에 결정을 내리기 쉽지 않다. 반대로 개발자는 프로그램이 어떻게 돌아갈지 본인이 직접 청사진을 그리므로 메모리를 어떻게 사용할 지 판단할 수 있다. 이에 따라 특정 프로그래밍 언어는 개발자에게 약간의 권한을 제공한다. 글 앞에서 든 예처럼 C 언어에서 메모리 할당은 malloc() 함수를 통해 이뤄지며, 할당 해제는 free() 함수를 통해 이뤄진다. 하지만 이 방식은 개발자가 꼼꼼히 메모리 관리를 한다는 전제가 깔려 있어야 제대로 작동한다. 개발자가 까먹고 메모리 반환을 하지 않으면 그 만큼의 메모리는 불필요하게 컴퓨터의 리소스를 잡아 먹게 되어 메모리 누수가 발생한다. 그러므로 현대의 high-level 언어에서는 시스템적으로 이 문제를 해결하려고 노력한다. 그 중 하나가 garbage collection의 활용이다.</p>
<h2 id="js%EC%97%90%EC%84%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC">JS에서 메모리 관리 <a class="direct-link" href="#js%EC%97%90%EC%84%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC">#</a></h2>
<p>JS는 garbage collection 기능을 사용한다. Garbage collector는 메모리가 사용되고 있는지 (e.g., 다른 것에 의해 reference되고 있는지) 주기적으로 확인한다. 만약 해당 메모리에 접근할 수 있는 수단이 없다면 (e.g., 아무 것도 해당 메모리를 reference하고 있지 않다면), 그 메모리는 사용되지 않다고 판단해 할당 해제한다. 즉, garbage collection은 메모리 관리의 문제를 &quot;어떤 메모리가 아직 필요한지&quot;에서 &quot;어떤 메모리가 앱의 다른 부분에 의해 아직 reference되는지&quot;로 치환시킨다. JS에서 메모리 관리는 메모리 관리는 시스템적으로 결정되고, 그 결정에 따라 메모리는 OS로 반환된다.</p>
<h2 id="reference-counting-garbage-collection">Reference-counting garbage collection <a class="direct-link" href="#reference-counting-garbage-collection">#</a></h2>
<p>가장 원시적인 garbage collection 방식은 메모리에 대한 reference count를 세서 0이면 반환하는 것이다. 여기서 &quot;reference 되었다&quot;의 엄밀한 정의는 해당 object를 그 외의 object가 참조하고 있다는 뜻이다. 예를 들어 JS의 object는 그에 대한 <code>prototype</code>을 참조하며, 이는 곳 해당 <code>prototype</code>의 reference count는 최소 1이란 말이다.</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token punctuation">{</span> <br>  a<span class="token operator">:</span> <span class="token punctuation">{</span><br>    b<span class="token operator">:</span> <span class="token number">2</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span> <br><span class="token comment">// 변수 x가 outer object를 참조함</span><br><span class="token comment">// 변수 a가 inner object를 참조함</span><br><span class="token comment">// 아무것도 garbage collected 되지 않음</span><br><br><span class="token keyword">var</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span>      <br><span class="token comment">// 변수 y가 outer object를 참조함</span><br><br>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          <br><span class="token comment">// outer object에 대한 변수 x의 참조가 풀림</span><br><span class="token comment">// 그래도 아직 변수 y가 참조하고 있으므로 garbage collected 되지 않음</span><br><br><span class="token keyword">var</span> z <span class="token operator">=</span> y<span class="token punctuation">.</span>a<span class="token punctuation">;</span> <br><span class="token comment">// 변수 z가 inner object를 참조함</span><br><br>y <span class="token operator">=</span> <span class="token string">'mozilla'</span><span class="token punctuation">;</span><br><span class="token comment">// outer object에 대한 변수 y의 참조가 풀림</span><br><span class="token comment">// outer object에 대한 reference count가 0이 되어 garbage collected 될 수 있음</span><br><span class="token comment">// 하지만 아직 inner object에 대한 참조가 남아 있어 아직 garbage collected 되지 않음</span><br><br>z <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><br><span class="token comment">// inner object에 대한 변수 z의 참조가 풀림</span><br><span class="token comment">// inner object에 대한 reference count가 0이 되어 garbage collected 될 수 있음</span><br><span class="token comment">// outer object, inner object 모두 garbaged collected 됨</span></code></pre>
<p>Reference-counting garbage collection은 이런 식으로 reference count가 0이 되면 해당 메모리를 <code>garbage</code>로 판단한다. 하지만 이같은 방식에 큰 문제점이 존재한다. Circular reference라는 특수한 상황이 생기면 실제 메모리가 쓰이지 않아도 reference count가 1 이상으로 유지되어 반환되지 않는다.</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><br>  <span class="token keyword">var</span> y <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><br>  x<span class="token punctuation">.</span>a <span class="token operator">=</span> y<span class="token punctuation">;</span>        <span class="token comment">// x가 y 참조</span><br>  y<span class="token punctuation">.</span>a <span class="token operator">=</span> x<span class="token punctuation">;</span>        <span class="token comment">// y가 x 참조</span><br><br>  <span class="token keyword">return</span> <span class="token string">'azerty'</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>위 코드의 경우 함수 <code>f</code>가 종료되면서 메모리가 모두 반화되어야 하지만 x, y object가 서로를 참조하면서 reference count는 1로 유지된다. 이로 인해 실제로 쓰이지 않지만 메모리는 반환되지 않고 불필요한 자리를 계속 차지하게 된다.</p>
<h2 id="mark-and-sweep-algorithm">Mark-and-sweep algorithm <a class="direct-link" href="#mark-and-sweep-algorithm">#</a></h2>
<p>위 문제를 해결하기 위해 고안된 방법이 mark-and-sweep algorithm이다. 실제로 현재 대부분의 garbage collection 알고리즘이 이를 기반으로 되어있다. 이 알고리즘은 다음의 단계대로 진행된다.</p>
<ol>
<li>Garbage collertor는 루트를 가지는 일종의 트리 구조를 유지한다. 루트는 주로 global variable로 설정되며, JS에서 'window' object가 루트로 작용하는 global variable의 예시다. window object는 어떤 상황에서든 존재하므로 garbage collector는 window 객체와 그것이 참조하고 있는 모든 children node를 유지한다.</li>
<li>루트는 active로 간주된다.(e.g., non-garbage). 루트의 모든 children node를 recursive하게 조사된다. 루트에서 시작해 참조 가능한 모든 메모리 조각은 active로 간주된다.</li>
<li>active로 표시되지 않은 모든 메모리 조각은 이제 garbage로 간주된다. garbage collector는 그 메모리를 할당 해제하여 OS에게 넘겨준다.</li>
</ol>
<p>이 방법을 사용하면 앞서 살펴봤던 circular reference 문제는 해결된다. 아무리 서로를 참조해도 루트로 이어져있지 않으면 garbage로 판단되기 때문이다. 최근 브라우저 엔진 등에 구현된 garbage collection 알고리즘은 모두 mark-and-sweep에서 발전되었다. 각 엔진마다 어느 정도 차이는 있겠지만 기본 원리는 같다. Root에서 도달 가능한 메모리는 남겨두고, 나머지 메모리는 모두 garbage로 판단한다.</p>
<h2 id="%EB%A7%88%EC%B9%98%EB%A9%B0">마치며 <a class="direct-link" href="#%EB%A7%88%EC%B9%98%EB%A9%B0">#</a></h2>
<p>메모리 누수는 어떤 프로그램에서든 발생할 수 있다. 만약 발생하게 되면 프로그램에 치명적인 성능 저하를 일으킨다. 물론 garbage collection 같이 시스템적으로 위 문제를 해결할 수 있지만 개발자가 사전에 메모리 누수를 방지할 수도 있다. 제품을 출시하기 전에 memory profiling tool 같이 메모리 누수를 사전에 탐색하는 과정을 통해 예기치 못한 사고에 대비하는 것도 좋은 방법이겠다. 끝!</p>
<p><strong>References</strong><br>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management">Memory Management - JavaScript | MDN</a><br>
<a href="https://javascript.info/garbage-collection">Garbage collection - JavaScript.info</a><br>
<a href="https://medium.com/front-end-weekly/understanding-javascript-memory-management-using-garbage-collection-35ed4954a67f">Understanding JavaScript Memory Management using Garbage Collection</a></p>


<hr>
<ul><li>Next: <a href="/posts/js-set/">[JS] Set</a></li><li>Previous: <a href="/posts/js-symbol/">[JS] Symbol</a></li>
</ul>

    </main>

    <footer></footer>

    <!-- Current page: /posts/garbage-collection-js/ -->
  </body>
</html>
